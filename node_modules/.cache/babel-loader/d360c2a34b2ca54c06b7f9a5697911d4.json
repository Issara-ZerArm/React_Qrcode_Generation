{"ast":null,"code":"\"use strict\";\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\n\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\n\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\n\nvar ModulusGF_1 = require(\"./ModulusGF\");\n/**\n * <p>PDF417 error correction implementation.</p>\n *\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n * is quite useful in understanding the algorithm.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n */\n\n\nvar ErrorCorrection =\n/** @class */\nfunction () {\n  function ErrorCorrection() {\n    this.field = ModulusGF_1.default.PDF417_GF;\n  }\n  /**\n   * @param received received codewords\n   * @param numECCodewords number of those codewords used for EC\n   * @param erasures location of erasures\n   * @return number of errors\n   * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n   */\n\n\n  ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n    var e_1, _a;\n\n    var poly = new ModulusPoly_1.default(this.field, received);\n    var S = new Int32Array(numECCodewords);\n    var error = false;\n\n    for (var i\n    /*int*/\n    = numECCodewords; i > 0; i--) {\n      var evaluation = poly.evaluateAt(this.field.exp(i));\n      S[numECCodewords - i] = evaluation;\n\n      if (evaluation !== 0) {\n        error = true;\n      }\n    }\n\n    if (!error) {\n      return 0;\n    }\n\n    var knownErrors = this.field.getOne();\n\n    if (erasures != null) {\n      try {\n        for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n          var erasure = erasures_1_1.value;\n          var b = this.field.exp(received.length - 1 - erasure); // Add (1 - bx) term:\n\n          var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n          knownErrors = knownErrors.multiply(term);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    var syndrome = new ModulusPoly_1.default(this.field, S); // syndrome = syndrome.multiply(knownErrors);\n\n    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1]; // sigma = sigma.multiply(knownErrors);\n\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n\n    for (var i\n    /*int*/\n    = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - this.field.log(errorLocations[i]);\n\n      if (position < 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n    }\n\n    return errorLocations.length;\n  };\n  /**\n   *\n   * @param ModulusPoly\n   * @param a\n   * @param ModulusPoly\n   * @param b\n   * @param int\n   * @param R\n   * @throws ChecksumException\n   */\n\n\n  ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n\n    var rLast = a;\n    var r = b;\n    var tLast = this.field.getZero();\n    var t = this.field.getOne(); // Run Euclidean algorithm until r's degree is less than R/2\n\n    while (r.getDegree() >= Math.round(R / 2)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      r = rLastLast;\n      var q = this.field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = this.field.inverse(denominatorLeadingTerm);\n\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.add(this.field.buildMonomial(degreeDiff, scale));\n        r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n\n      t = q.multiply(tLast).subtract(tLastLast).negative();\n    }\n\n    var sigmaTildeAtZero = t.getCoefficient(0);\n\n    if (sigmaTildeAtZero === 0) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    var inverse = this.field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiply(inverse);\n    var omega = r.multiply(inverse);\n    return [sigma, omega];\n  };\n  /**\n   *\n   * @param errorLocator\n   * @throws ChecksumException\n   */\n\n\n  ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n    var result = new Int32Array(numErrors);\n    var e = 0;\n\n    for (var i\n    /*int*/\n    = 1; i < this.field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = this.field.inverse(i);\n        e++;\n      }\n    }\n\n    if (e !== numErrors) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    return result;\n  };\n\n  ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n    var errorLocatorDegree = errorLocator.getDegree();\n    var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n\n    for (var i\n    /*int*/\n    = 1; i <= errorLocatorDegree; i++) {\n      formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));\n    }\n\n    var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients); // This is directly applying Forney's Formula\n\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n\n    for (var i\n    /*int*/\n    = 0; i < s; i++) {\n      var xiInverse = this.field.inverse(errorLocations[i]);\n      var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n      var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n      result[i] = this.field.multiply(numerator, denominator);\n    }\n\n    return result;\n  };\n\n  return ErrorCorrection;\n}();\n\nexports.default = ErrorCorrection;","map":{"version":3,"mappings":"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","names":["field","ModulusGF_1","PDF417_GF","ErrorCorrection","received","numECCodewords","erasures","poly","ModulusPoly_1","S","Int32Array","error","i","evaluation","evaluateAt","exp","knownErrors","getOne","erasures_1_1","erasure","b","length","term","subtract","multiply","syndrome","sigmaOmega","runEuclideanAlgorithm","buildMonomial","sigma","omega","errorLocations","findErrorLocations","errorMagnitudes","findErrorMagnitudes","position","log","ChecksumException_1","getChecksumInstance","a","R","getDegree","temp","rLast","r","tLast","getZero","t","Math","round","rLastLast","tLastLast","isZero","q","denominatorLeadingTerm","getCoefficient","dltInverse","inverse","degreeDiff","scale","add","multiplyByMonomial","negative","sigmaTildeAtZero","errorLocator","numErrors","result","e","getSize","errorEvaluator","errorLocatorDegree","formalDerivativeCoefficients","formalDerivative","s","xiInverse","numerator","denominator"],"sources":["../../../../../src/core/pdf417/decoder/ec/ErrorCorrection.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.reedsolomon {*/\n\nvar GenericGF_1 = require(\"./GenericGF\");\n\nvar GenericGFPoly_1 = require(\"./GenericGFPoly\");\n\nvar ReedSolomonException_1 = require(\"../../ReedSolomonException\");\n\nvar IllegalStateException_1 = require(\"../../IllegalStateException\");\n/**\n * <p>Implements Reed-Solomon decoding, as the name implies.</p>\n *\n * <p>The algorithm will not be explained here, but the following references were helpful\n * in creating this implementation:</p>\n *\n * <ul>\n * <li>Bruce Maggs.\n * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\n * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\n * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\n * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\n * (see discussion of Euclidean algorithm)</li>\n * </ul>\n *\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n * port of his C++ Reed-Solomon implementation.</p>\n *\n * @author Sean Owen\n * @author William Rucklidge\n * @author sanfordsquires\n */\n\n\nvar ReedSolomonDecoder =\n/** @class */\nfunction () {\n  function ReedSolomonDecoder(field) {\n    this.field = field;\n  }\n  /**\n   * <p>Decodes given set of received codewords, which include both data and error-correction\n   * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\n   * in the input.</p>\n   *\n   * @param received data and error-correction codewords\n   * @param twoS number of error-correction codewords available\n   * @throws ReedSolomonException if decoding fails for any reason\n   */\n\n\n  ReedSolomonDecoder.prototype.decode = function (received, twoS\n  /*int*/\n  ) {\n    var field = this.field;\n    var poly = new GenericGFPoly_1.default(field, received);\n    var syndromeCoefficients = new Int32Array(twoS);\n    var noError = true;\n\n    for (var i = 0; i < twoS; i++) {\n      var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n      syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n\n      if (evalResult !== 0) {\n        noError = false;\n      }\n    }\n\n    if (noError) {\n      return;\n    }\n\n    var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);\n    var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1];\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n\n    for (var i = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - field.log(errorLocations[i]);\n\n      if (position < 0) {\n        throw new ReedSolomonException_1.default('Bad error location');\n      }\n\n      received[position] = GenericGF_1.default.addOrSubtract(received[position], errorMagnitudes[i]);\n    }\n  };\n\n  ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R\n  /*int*/\n  ) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n\n    var field = this.field;\n    var rLast = a;\n    var r = b;\n    var tLast = field.getZero();\n    var t = field.getOne(); // Run Euclidean algorithm until r's degree is less than R/2\n\n    while (r.getDegree() >= (R / 2 | 0)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw new ReedSolomonException_1.default('r_{i-1} was zero');\n      }\n\n      r = rLastLast;\n      var q = field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = field.inverse(denominatorLeadingTerm);\n\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n        r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n\n      t = q.multiply(tLast).addOrSubtract(tLastLast);\n\n      if (r.getDegree() >= rLast.getDegree()) {\n        throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');\n      }\n    }\n\n    var sigmaTildeAtZero = t.getCoefficient(0);\n\n    if (sigmaTildeAtZero === 0) {\n      throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');\n    }\n\n    var inverse = field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiplyScalar(inverse);\n    var omega = r.multiplyScalar(inverse);\n    return [sigma, omega];\n  };\n\n  ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n\n    if (numErrors === 1) {\n      // shortcut\n      return Int32Array.from([errorLocator.getCoefficient(1)]);\n    }\n\n    var result = new Int32Array(numErrors);\n    var e = 0;\n    var field = this.field;\n\n    for (var i = 1; i < field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = field.inverse(i);\n        e++;\n      }\n    }\n\n    if (e !== numErrors) {\n      throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');\n    }\n\n    return result;\n  };\n\n  ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {\n    // This is directly applying Forney's Formula\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n    var field = this.field;\n\n    for (var i = 0; i < s; i++) {\n      var xiInverse = field.inverse(errorLocations[i]);\n      var denominator = 1;\n\n      for (var j = 0; j < s; j++) {\n        if (i !== j) {\n          // denominator = field.multiply(denominator,\n          //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n          // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n          // Below is a funny-looking workaround from Steven Parkes\n          var term = field.multiply(errorLocations[j], xiInverse);\n          var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n          denominator = field.multiply(denominator, termPlus1);\n        }\n      }\n\n      result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n\n      if (field.getGeneratorBase() !== 0) {\n        result[i] = field.multiply(result[i], xiInverse);\n      }\n    }\n\n    return result;\n  };\n\n  return ReedSolomonDecoder;\n}();\n\nexports.default = ReedSolomonDecoder;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAgBA;;AAEA;;AACA;;AAEA;;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAEI,8BAA2BA,KAA3B,EAA2C;AAAhB;AAAqB;AAEhD;;;;;;;;;;;AASOC,wCAAP,UAAcC,QAAd,EAAoCC;AAAa;AAAjD,IAAwD;AACpD,QAAMH,KAAK,GAAG,KAAKA,KAAnB;AACA,QAAMI,IAAI,GAAG,IAAIC,uBAAJ,CAAkBL,KAAlB,EAAyBE,QAAzB,CAAb;AACA,QAAMI,oBAAoB,GAAG,IAAIC,UAAJ,CAAeJ,IAAf,CAA7B;AACA,QAAIK,OAAO,GAAY,IAAvB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAApB,EAA0BM,CAAC,EAA3B,EAA+B;AAC3B,UAAMC,UAAU,GAAGN,IAAI,CAACO,UAAL,CAAgBX,KAAK,CAACY,GAAN,CAAUH,CAAC,GAAGT,KAAK,CAACa,gBAAN,EAAd,CAAhB,CAAnB;AACAP,0BAAoB,CAACA,oBAAoB,CAACQ,MAArB,GAA8B,CAA9B,GAAkCL,CAAnC,CAApB,GAA4DC,UAA5D;;AACA,UAAIA,UAAU,KAAK,CAAnB,EAAsB;AAClBF,eAAO,GAAG,KAAV;AACH;AACJ;;AACD,QAAIA,OAAJ,EAAa;AACT;AACH;;AACD,QAAMO,QAAQ,GAAG,IAAIV,uBAAJ,CAAkBL,KAAlB,EAAyBM,oBAAzB,CAAjB;AACA,QAAMU,UAAU,GAAG,KAAKC,qBAAL,CAA2BjB,KAAK,CAACkB,aAAN,CAAoBf,IAApB,EAA0B,CAA1B,CAA3B,EAAyDY,QAAzD,EAAmEZ,IAAnE,CAAnB;AACA,QAAMgB,KAAK,GAAGH,UAAU,CAAC,CAAD,CAAxB;AACA,QAAMI,KAAK,GAAGJ,UAAU,CAAC,CAAD,CAAxB;AACA,QAAMK,cAAc,GAAG,KAAKC,kBAAL,CAAwBH,KAAxB,CAAvB;AACA,QAAMI,eAAe,GAAG,KAAKC,mBAAL,CAAyBJ,KAAzB,EAAgCC,cAAhC,CAAxB;;AACA,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,cAAc,CAACP,MAAnC,EAA2CL,CAAC,EAA5C,EAAgD;AAC5C,UAAMgB,QAAQ,GAAGvB,QAAQ,CAACY,MAAT,GAAkB,CAAlB,GAAsBd,KAAK,CAAC0B,GAAN,CAAUL,cAAc,CAACZ,CAAD,CAAxB,CAAvC;;AACA,UAAIgB,QAAQ,GAAG,CAAf,EAAkB;AACd,cAAM,IAAIE,8BAAJ,CAAyB,oBAAzB,CAAN;AACH;;AACDzB,cAAQ,CAACuB,QAAD,CAAR,GAAqBG,oBAAUC,aAAV,CAAwB3B,QAAQ,CAACuB,QAAD,CAAhC,EAA4CF,eAAe,CAACd,CAAD,CAA3D,CAArB;AACH;AACJ,GA5BM;;AA8BCR,uDAAR,UAA8B6B,CAA9B,EAAgDC,CAAhD,EAAkEC;AAAU;AAA5E,IAAmF;AAC/E;AACA,QAAIF,CAAC,CAACG,SAAF,KAAgBF,CAAC,CAACE,SAAF,EAApB,EAAmC;AAC/B,UAAMC,IAAI,GAAGJ,CAAb;AACAA,OAAC,GAAGC,CAAJ;AACAA,OAAC,GAAGG,IAAJ;AACH;;AAED,QAAMlC,KAAK,GAAG,KAAKA,KAAnB;AAEA,QAAImC,KAAK,GAAGL,CAAZ;AACA,QAAIM,CAAC,GAAGL,CAAR;AACA,QAAIM,KAAK,GAAGrC,KAAK,CAACsC,OAAN,EAAZ;AACA,QAAIC,CAAC,GAAGvC,KAAK,CAACwC,MAAN,EAAR,CAb+E,CAe/E;;AACA,WAAOJ,CAAC,CAACH,SAAF,OAAkBD,CAAC,GAAG,CAAJ,GAAQ,CAA1B,CAAP,EAAqC;AACjC,UAAIS,SAAS,GAAGN,KAAhB;AACA,UAAIO,SAAS,GAAGL,KAAhB;AACAF,WAAK,GAAGC,CAAR;AACAC,WAAK,GAAGE,CAAR,CAJiC,CAMjC;;AACA,UAAIJ,KAAK,CAACQ,MAAN,EAAJ,EAAoB;AAChB;AACA,cAAM,IAAIhB,8BAAJ,CAAyB,kBAAzB,CAAN;AACH;;AACDS,OAAC,GAAGK,SAAJ;AACA,UAAIG,CAAC,GAAG5C,KAAK,CAACsC,OAAN,EAAR;AACA,UAAMO,sBAAsB,GAAGV,KAAK,CAACW,cAAN,CAAqBX,KAAK,CAACF,SAAN,EAArB,CAA/B;AACA,UAAMc,UAAU,GAAG/C,KAAK,CAACgD,OAAN,CAAcH,sBAAd,CAAnB;;AACA,aAAOT,CAAC,CAACH,SAAF,MAAiBE,KAAK,CAACF,SAAN,EAAjB,IAAsC,CAACG,CAAC,CAACO,MAAF,EAA9C,EAA0D;AACtD,YAAMM,UAAU,GAAGb,CAAC,CAACH,SAAF,KAAgBE,KAAK,CAACF,SAAN,EAAnC;AACA,YAAMiB,KAAK,GAAGlD,KAAK,CAACmD,QAAN,CAAef,CAAC,CAACU,cAAF,CAAiBV,CAAC,CAACH,SAAF,EAAjB,CAAf,EAAgDc,UAAhD,CAAd;AACAH,SAAC,GAAGA,CAAC,CAACf,aAAF,CAAgB7B,KAAK,CAACkB,aAAN,CAAoB+B,UAApB,EAAgCC,KAAhC,CAAhB,CAAJ;AACAd,SAAC,GAAGA,CAAC,CAACP,aAAF,CAAgBM,KAAK,CAACiB,kBAAN,CAAyBH,UAAzB,EAAqCC,KAArC,CAAhB,CAAJ;AACH;;AAEDX,OAAC,GAAGK,CAAC,CAACO,QAAF,CAAWd,KAAX,EAAkBR,aAAlB,CAAgCa,SAAhC,CAAJ;;AAEA,UAAIN,CAAC,CAACH,SAAF,MAAiBE,KAAK,CAACF,SAAN,EAArB,EAAwC;AACpC,cAAM,IAAIoB,+BAAJ,CAA0B,iDAA1B,CAAN;AACH;AACJ;;AAED,QAAMC,gBAAgB,GAAGf,CAAC,CAACO,cAAF,CAAiB,CAAjB,CAAzB;;AACA,QAAIQ,gBAAgB,KAAK,CAAzB,EAA4B;AACxB,YAAM,IAAI3B,8BAAJ,CAAyB,wBAAzB,CAAN;AACH;;AAED,QAAMqB,OAAO,GAAGhD,KAAK,CAACgD,OAAN,CAAcM,gBAAd,CAAhB;AACA,QAAMnC,KAAK,GAAGoB,CAAC,CAACgB,cAAF,CAAiBP,OAAjB,CAAd;AACA,QAAM5B,KAAK,GAAGgB,CAAC,CAACmB,cAAF,CAAiBP,OAAjB,CAAd;AACA,WAAO,CAAC7B,KAAD,EAAQC,KAAR,CAAP;AACH,GAtDO;;AAwDAnB,oDAAR,UAA2BuD,YAA3B,EAAsD;AAClD;AACA,QAAMC,SAAS,GAAGD,YAAY,CAACvB,SAAb,EAAlB;;AACA,QAAIwB,SAAS,KAAK,CAAlB,EAAqB;AAAE;AACnB,aAAOlD,UAAU,CAACmD,IAAX,CAAgB,CAACF,YAAY,CAACV,cAAb,CAA4B,CAA5B,CAAD,CAAhB,CAAP;AACH;;AACD,QAAMa,MAAM,GAAG,IAAIpD,UAAJ,CAAekD,SAAf,CAAf;AACA,QAAIG,CAAC,GAAG,CAAR;AACA,QAAM5D,KAAK,GAAG,KAAKA,KAAnB;;AACA,SAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,KAAK,CAAC6D,OAAN,EAAJ,IAAuBD,CAAC,GAAGH,SAA3C,EAAsDhD,CAAC,EAAvD,EAA2D;AACvD,UAAI+C,YAAY,CAAC7C,UAAb,CAAwBF,CAAxB,MAA+B,CAAnC,EAAsC;AAClCkD,cAAM,CAACC,CAAD,CAAN,GAAY5D,KAAK,CAACgD,OAAN,CAAcvC,CAAd,CAAZ;AACAmD,SAAC;AACJ;AACJ;;AACD,QAAIA,CAAC,KAAKH,SAAV,EAAqB;AACjB,YAAM,IAAI9B,8BAAJ,CAAyB,qDAAzB,CAAN;AACH;;AACD,WAAOgC,MAAP;AACH,GAnBO;;AAqBA1D,qDAAR,UAA4B6D,cAA5B,EAA2DzC,cAA3D,EAAqF;AACjF;AACA,QAAM0C,CAAC,GAAG1C,cAAc,CAACP,MAAzB;AACA,QAAM6C,MAAM,GAAG,IAAIpD,UAAJ,CAAewD,CAAf,CAAf;AACA,QAAM/D,KAAK,GAAG,KAAKA,KAAnB;;AACA,SAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsD,CAApB,EAAuBtD,CAAC,EAAxB,EAA4B;AACxB,UAAMuD,SAAS,GAAGhE,KAAK,CAACgD,OAAN,CAAc3B,cAAc,CAACZ,CAAD,CAA5B,CAAlB;AACA,UAAIwD,WAAW,GAAG,CAAlB;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAApB,EAAuBG,CAAC,EAAxB,EAA4B;AACxB,YAAIzD,CAAC,KAAKyD,CAAV,EAAa;AACT;AACA;AACA;AACA;AACA,cAAMC,IAAI,GAAGnE,KAAK,CAACmD,QAAN,CAAe9B,cAAc,CAAC6C,CAAD,CAA7B,EAAkCF,SAAlC,CAAb;AACA,cAAMI,SAAS,GAAG,CAACD,IAAI,GAAG,GAAR,MAAiB,CAAjB,GAAqBA,IAAI,GAAG,CAA5B,GAAgCA,IAAI,GAAG,CAAC,CAA1D;AACAF,qBAAW,GAAGjE,KAAK,CAACmD,QAAN,CAAec,WAAf,EAA4BG,SAA5B,CAAd;AACH;AACJ;;AACDT,YAAM,CAAClD,CAAD,CAAN,GAAYT,KAAK,CAACmD,QAAN,CAAeW,cAAc,CAACnD,UAAf,CAA0BqD,SAA1B,CAAf,EACRhE,KAAK,CAACgD,OAAN,CAAciB,WAAd,CADQ,CAAZ;;AAEA,UAAIjE,KAAK,CAACa,gBAAN,OAA6B,CAAjC,EAAoC;AAChC8C,cAAM,CAAClD,CAAD,CAAN,GAAYT,KAAK,CAACmD,QAAN,CAAeQ,MAAM,CAAClD,CAAD,CAArB,EAA0BuD,SAA1B,CAAZ;AACH;AACJ;;AACD,WAAOL,MAAP;AACH,GA1BO;;AA4BZ;AAAC,CApJD","names":["field","ReedSolomonDecoder","received","twoS","poly","GenericGFPoly_1","syndromeCoefficients","Int32Array","noError","i","evalResult","evaluateAt","exp","getGeneratorBase","length","syndrome","sigmaOmega","runEuclideanAlgorithm","buildMonomial","sigma","omega","errorLocations","findErrorLocations","errorMagnitudes","findErrorMagnitudes","position","log","ReedSolomonException_1","GenericGF_1","addOrSubtract","a","b","R","getDegree","temp","rLast","r","tLast","getZero","t","getOne","rLastLast","tLastLast","isZero","q","denominatorLeadingTerm","getCoefficient","dltInverse","inverse","degreeDiff","scale","multiply","multiplyByMonomial","IllegalStateException_1","sigmaTildeAtZero","multiplyScalar","errorLocator","numErrors","from","result","e","getSize","errorEvaluator","s","xiInverse","denominator","j","term","termPlus1"],"sources":["../../../../src/core/common/reedsolomon/ReedSolomonDecoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
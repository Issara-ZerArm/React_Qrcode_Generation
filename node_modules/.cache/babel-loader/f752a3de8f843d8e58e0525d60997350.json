{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode.detector {*/\n\nvar DecodeHintType_1 = require(\"../../DecodeHintType\");\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\n\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\n\nvar PerspectiveTransform_1 = require(\"../../common/PerspectiveTransform\");\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n\nvar Version_1 = require(\"../decoder/Version\");\n\nvar FinderPatternFinder_1 = require(\"./FinderPatternFinder\");\n\nvar AlignmentPatternFinder_1 = require(\"./AlignmentPatternFinder\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*import java.util.Map;*/\n\n/**\n * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\n\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector(image) {\n    this.image = image;\n  }\n\n  Detector.prototype.getImage = function () {\n    return this.image;\n  };\n\n  Detector.prototype.getResultPointCallback = function () {\n    return this.resultPointCallback;\n  };\n  /**\n   * <p>Detects a QR Code in an image.</p>\n   *\n   * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n   * @throws NotFoundException if QR Code cannot be found\n   * @throws FormatException if a QR Code cannot be decoded\n   */\n  // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n  //   return detect(null)\n  // }\n\n  /**\n   * <p>Detects a QR Code in an image.</p>\n   *\n   * @param hints optional hints to detector\n   * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n   * @throws NotFoundException if QR Code cannot be found\n   * @throws FormatException if a QR Code cannot be decoded\n   */\n\n\n  Detector.prototype.detect = function (hints) {\n    this.resultPointCallback = hints === null || hints === undefined ? null :\n    /*(ResultPointCallback) */\n    hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n    var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);\n    var info = finder.find(hints);\n    return this.processFinderPatternInfo(info);\n  };\n\n  Detector.prototype.processFinderPatternInfo = function (info) {\n    var topLeft = info.getTopLeft();\n    var topRight = info.getTopRight();\n    var bottomLeft = info.getBottomLeft();\n    var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n\n    if (moduleSize < 1.0) {\n      throw new NotFoundException_1.default('No pattern found in proccess finder.');\n    }\n\n    var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n    var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);\n    var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n    var alignmentPattern = null; // Anything above version 1 has an alignment pattern\n\n    if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n      // Guess where a \"bottom right\" finder pattern would have been\n      var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n      var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY(); // Estimate that alignment pattern is closer by 3 modules\n      // from \"bottom right\" to known top left location\n\n      var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n      var estAlignmentX =\n      /*(int) */\n      Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n      var estAlignmentY =\n      /*(int) */\n      Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY())); // Kind of arbitrary -- expand search radius before giving up\n\n      for (var i = 4; i <= 16; i <<= 1) {\n        try {\n          alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n          break;\n        } catch (re\n        /*NotFoundException*/\n        ) {\n          if (!(re instanceof NotFoundException_1.default)) {\n            throw re;\n          } // try next round\n\n        }\n      } // If we didn't find alignment pattern... well try anyway without it\n\n    }\n\n    var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n    var bits = Detector.sampleGrid(this.image, transform, dimension);\n    var points;\n\n    if (alignmentPattern === null) {\n      points = [bottomLeft, topLeft, topRight];\n    } else {\n      points = [bottomLeft, topLeft, topRight, alignmentPattern];\n    }\n\n    return new DetectorResult_1.default(bits, points);\n  };\n\n  Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension\n  /*int*/\n  ) {\n    var dimMinusThree = dimension - 3.5;\n    var bottomRightX;\n    /*float*/\n\n    var bottomRightY;\n    /*float*/\n\n    var sourceBottomRightX;\n    /*float*/\n\n    var sourceBottomRightY;\n    /*float*/\n\n    if (alignmentPattern !== null) {\n      bottomRightX = alignmentPattern.getX();\n      bottomRightY = alignmentPattern.getY();\n      sourceBottomRightX = dimMinusThree - 3.0;\n      sourceBottomRightY = sourceBottomRightX;\n    } else {\n      // Don't have an alignment pattern, just make up the bottom-right point\n      bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n      bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n      sourceBottomRightX = dimMinusThree;\n      sourceBottomRightY = dimMinusThree;\n    }\n\n    return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n  };\n\n  Detector.sampleGrid = function (image, transform, dimension\n  /*int*/\n  ) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n  };\n  /**\n   * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n   * of the finder patterns and estimated module size.</p>\n   */\n\n\n  Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize\n  /*float*/\n  ) {\n    var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);\n    var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);\n    var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n\n    switch (dimension & 0x03) {\n      // mod 4\n      case 0:\n        dimension++;\n        break;\n      // 1? do nothing\n\n      case 2:\n        dimension--;\n        break;\n\n      case 3:\n        throw new NotFoundException_1.default('Dimensions could be not found.');\n    }\n\n    return dimension;\n  };\n  /**\n   * <p>Computes an average estimated module size based on estimated derived from the positions\n   * of the three finder patterns.</p>\n   *\n   * @param topLeft detected top-left finder pattern center\n   * @param topRight detected top-right finder pattern center\n   * @param bottomLeft detected bottom-left finder pattern center\n   * @return estimated module size\n   */\n\n\n  Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n    // Take the average\n    return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n  };\n  /**\n   * <p>Estimates module size based on two finder patterns -- it uses\n   * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n   * width of each, measuring along the axis between their centers.</p>\n   */\n\n\n  Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n    var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(\n    /*(int) */\n    Math.floor(pattern.getX()),\n    /*(int) */\n    Math.floor(pattern.getY()),\n    /*(int) */\n    Math.floor(otherPattern.getX()),\n    /*(int) */\n    Math.floor(otherPattern.getY()));\n    var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(\n    /*(int) */\n    Math.floor(otherPattern.getX()),\n    /*(int) */\n    Math.floor(otherPattern.getY()),\n    /*(int) */\n    Math.floor(pattern.getX()),\n    /*(int) */\n    Math.floor(pattern.getY()));\n\n    if (isNaN(moduleSizeEst1)) {\n      return moduleSizeEst2 / 7.0;\n    }\n\n    if (isNaN(moduleSizeEst2)) {\n      return moduleSizeEst1 / 7.0;\n    } // Average them, and divide by 7 since we've counted the width of 3 black modules,\n    // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n\n\n    return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n  };\n  /**\n   * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n   * a finder pattern by looking for a black-white-black run from the center in the direction\n   * of another point (another finder pattern center), and in the opposite direction too.\n   */\n\n\n  Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX\n  /*int*/\n  , fromY\n  /*int*/\n  , toX\n  /*int*/\n  , toY\n  /*int*/\n  ) {\n    var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY); // Now count other way -- don't run off image though of course\n\n    var scale = 1.0;\n    var otherToX = fromX - (toX - fromX);\n\n    if (otherToX < 0) {\n      scale = fromX / (\n      /*(float) */\n      fromX - otherToX);\n      otherToX = 0;\n    } else if (otherToX >= this.image.getWidth()) {\n      scale = (this.image.getWidth() - 1 - fromX) / (\n      /*(float) */\n      otherToX - fromX);\n      otherToX = this.image.getWidth() - 1;\n    }\n\n    var otherToY =\n    /*(int) */\n    Math.floor(fromY - (toY - fromY) * scale);\n    scale = 1.0;\n\n    if (otherToY < 0) {\n      scale = fromY / (\n      /*(float) */\n      fromY - otherToY);\n      otherToY = 0;\n    } else if (otherToY >= this.image.getHeight()) {\n      scale = (this.image.getHeight() - 1 - fromY) / (\n      /*(float) */\n      otherToY - fromY);\n      otherToY = this.image.getHeight() - 1;\n    }\n\n    otherToX =\n    /*(int) */\n    Math.floor(fromX + (otherToX - fromX) * scale);\n    result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY); // Middle pixel is double-counted this way; subtract 1\n\n    return result - 1.0;\n  };\n  /**\n   * <p>This method traces a line from a point in the image, in the direction towards another point.\n   * It begins in a black region, and keeps going until it finds white, then black, then white again.\n   * It reports the distance from the start to this point.</p>\n   *\n   * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n   * may be skewed or rotated.</p>\n   */\n\n\n  Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX\n  /*int*/\n  , fromY\n  /*int*/\n  , toX\n  /*int*/\n  , toY\n  /*int*/\n  ) {\n    // Mild variant of Bresenham's algorithm\n    // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx / 2;\n    var xstep = fromX < toX ? 1 : -1;\n    var ystep = fromY < toY ? 1 : -1; // In black pixels, looking for white, first or second time.\n\n    var state = 0; // Loop up until x == toX, but not beyond\n\n    var xLimit = toX + xstep;\n\n    for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {\n      var realX = steep ? y : x;\n      var realY = steep ? x : y; // Does current pixel mean we have moved white to black or vice versa?\n      // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n      // color, advance to next state or end if we are in state 2 already\n\n      if (state === 1 === this.image.get(realX, realY)) {\n        if (state === 2) {\n          return MathUtils_1.default.distance(x, y, fromX, fromY);\n        }\n\n        state++;\n      }\n\n      error += dy;\n\n      if (error > 0) {\n        if (y === toY) {\n          break;\n        }\n\n        y += ystep;\n        error -= dx;\n      }\n    } // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n    // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n    // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n\n\n    if (state === 2) {\n      return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);\n    } // else we didn't find even black-white-black; no estimate is really possible\n\n\n    return NaN;\n  };\n  /**\n   * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n   * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n   *\n   * @param overallEstModuleSize estimated module size so far\n   * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n   * @param estAlignmentY y coordinate of above\n   * @param allowanceFactor number of pixels in all directions to search from the center\n   * @return {@link AlignmentPattern} if found, or null otherwise\n   * @throws NotFoundException if an unexpected error occurs during detection\n   */\n\n\n  Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize\n  /*float*/\n  , estAlignmentX\n  /*int*/\n  , estAlignmentY\n  /*int*/\n  , allowanceFactor\n  /*float*/\n  ) {\n    // Look for an alignment pattern (3 modules in size) around where it\n    // should be\n    var allowance =\n    /*(int) */\n    Math.floor(allowanceFactor * overallEstModuleSize);\n    var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n    var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n\n    if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n      throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');\n    }\n\n    var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n    var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n\n    if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n      throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');\n    }\n\n    var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n    return alignmentFinder.find();\n  };\n\n  return Detector;\n}();\n\nexports.default = Detector;","map":{"version":3,"mappings":"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","names":["image","Detector","resultPointCallback","hints","undefined","get","DecodeHintType_1","NEED_RESULT_POINT_CALLBACK","finder","FinderPatternFinder_1","info","find","processFinderPatternInfo","topLeft","getTopLeft","topRight","getTopRight","bottomLeft","getBottomLeft","moduleSize","calculateModuleSize","NotFoundException_1","dimension","computeDimension","provisionalVersion","Version_1","getProvisionalVersionForDimension","modulesBetweenFPCenters","getDimensionForVersion","alignmentPattern","getAlignmentPatternCenters","length","bottomRightX","getX","bottomRightY","getY","correctionToTopLeft","estAlignmentX","Math","floor","estAlignmentY","i","findAlignmentInRegion","re","transform","createTransform","bits","sampleGrid","points","DetectorResult_1","dimMinusThree","sourceBottomRightX","sourceBottomRightY","PerspectiveTransform_1","quadrilateralToQuadrilateral","sampler","GridSamplerInstance_1","getInstance","sampleGridWithTransform","tltrCentersDimension","MathUtils_1","round","ResultPoint_1","distance","tlblCentersDimension","calculateModuleSizeOneWay","pattern","otherPattern","moduleSizeEst1","sizeOfBlackWhiteBlackRunBothWays","moduleSizeEst2","isNaN","fromX","fromY","toX","toY","result","sizeOfBlackWhiteBlackRun","scale","otherToX","getWidth","otherToY","getHeight","steep","abs","temp","dx","dy","error","xstep","ystep","state","xLimit","x","y","realX","realY","NaN","overallEstModuleSize","allowanceFactor","allowance","alignmentAreaLeftX","max","alignmentAreaRightX","min","alignmentAreaTopY","alignmentAreaBottomY","alignmentFinder","AlignmentPatternFinder_1"],"sources":["../../../../src/core/qrcode/detector/Detector.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
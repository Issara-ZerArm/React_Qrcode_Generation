{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Decoder_1 = require(\"./decoder/Decoder\");\n\nvar Result_1 = require(\"../Result\");\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\n\nvar Detector_1 = require(\"./detector/Detector\");\n\nvar System_1 = require(\"../util/System\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\n\n\nvar DataMatrixReader =\n/** @class */\nfunction () {\n  function DataMatrixReader() {\n    this.decoder = new Decoder_1.default();\n  }\n  /**\n   * Locates and decodes a Data Matrix code in an image.\n   *\n   * @return a String representing the content encoded by the Data Matrix code\n   * @throws NotFoundException if a Data Matrix code cannot be found\n   * @throws FormatException if a Data Matrix code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  // @Override\n  // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n  //   return decode(image, null);\n  // }\n  // @Override\n\n\n  DataMatrixReader.prototype.decode = function (image, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n\n    var decoderResult;\n    var points;\n\n    if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {\n      var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decode(bits);\n      points = DataMatrixReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();\n      decoderResult = this.decoder.decode(detectorResult.getBits());\n      points = detectorResult.getPoints();\n    }\n\n    var rawBytes = decoderResult.getRawBytes();\n    var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());\n    var byteSegments = decoderResult.getByteSegments();\n\n    if (byteSegments != null) {\n      result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n    }\n\n    var ecLevel = decoderResult.getECLevel();\n\n    if (ecLevel != null) {\n      result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n\n    return result;\n  }; // @Override\n\n\n  DataMatrixReader.prototype.reset = function () {// do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n   */\n\n\n  DataMatrixReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n\n    if (leftTopBlack == null || rightBottomBlack == null) {\n      throw new NotFoundException_1.default();\n    }\n\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    var matrixWidth = (right - left + 1) / moduleSize;\n    var matrixHeight = (bottom - top + 1) / moduleSize;\n\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException_1.default();\n    } // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n\n\n    var nudge = moduleSize / 2;\n    top += nudge;\n    left += nudge; // Now just read off the bits\n\n    var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + y * moduleSize;\n\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + x * moduleSize, iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n\n    return bits;\n  };\n\n  DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n\n    while (x < width && image.get(x, y)) {\n      x++;\n    }\n\n    if (x === width) {\n      throw new NotFoundException_1.default();\n    }\n\n    var moduleSize = x - leftTopBlack[0];\n\n    if (moduleSize === 0) {\n      throw new NotFoundException_1.default();\n    }\n\n    return moduleSize;\n  };\n\n  DataMatrixReader.NO_POINTS = [];\n  return DataMatrixReader;\n}();\n\nexports.default = DataMatrixReader;","map":{"version":3,"mappings":"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","names":["Decoder_1","DataMatrixReader","image","hints","decoderResult","points","has","DecodeHintType_1","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","decoder","decode","NO_POINTS","detectorResult","Detector_1","detect","getBits","getPoints","rawBytes","getRawBytes","result","Result_1","getText","length","BarcodeFormat_1","DATA_MATRIX","System_1","currentTimeMillis","byteSegments","getByteSegments","putMetadata","ResultMetadataType_1","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","NotFoundException_1","moduleSize","top","bottom","left","right","matrixWidth","matrixHeight","nudge","BitMatrix_1","y","iOffset","x","get","set","width","getWidth"],"sources":["../../../src/core/datamatrix/DataMatrixReader.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
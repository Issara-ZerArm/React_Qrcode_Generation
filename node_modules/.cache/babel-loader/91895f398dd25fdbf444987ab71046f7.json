{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar DataMaskValues;\n\n(function (DataMaskValues) {\n  DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));\n/**\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n * after the point they are unmasked anyway.</p>\n *\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n *\n * @author Sean Owen\n */\n\n\nvar DataMask =\n/** @class */\nfunction () {\n  // See ISO 18004:2006 6.8.1\n  function DataMask(value, isMasked) {\n    this.value = value;\n    this.isMasked = isMasked;\n  } // End of enum constants.\n\n  /**\n   * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n   * make its bits ready to read.</p>\n   *\n   * @param bits representation of QR Code bits\n   * @param dimension dimension of QR Code, represented by bits, being unmasked\n   */\n\n\n  DataMask.prototype.unmaskBitMatrix = function (bits, dimension\n  /*int*/\n  ) {\n    for (var i = 0; i < dimension; i++) {\n      for (var j = 0; j < dimension; j++) {\n        if (this.isMasked(i, j)) {\n          bits.flip(j, i);\n        }\n      }\n    }\n  };\n\n  DataMask.values = new Map([\n  /**\n   * 000: mask bits for which (x + y) mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return (i + j & 0x01) === 0;\n  })],\n  /**\n   * 001: mask bits for which x mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return (i & 0x01) === 0;\n  })],\n  /**\n   * 010: mask bits for which y mod 3 == 0\n   */\n  [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return j % 3 === 0;\n  })],\n  /**\n   * 011: mask bits for which (x + y) mod 3 == 0\n   */\n  [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return (i + j) % 3 === 0;\n  })],\n  /**\n   * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return (Math.floor(i / 2) + Math.floor(j / 3) & 0x01) === 0;\n  })],\n  /**\n   * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n   * equivalently, such that xy mod 6 == 0\n   */\n  [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return i * j % 6 === 0;\n  })],\n  /**\n   * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n   * equivalently, such that xy mod 6 < 3\n   */\n  [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return i * j % 6 < 3;\n  })],\n  /**\n   * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n   * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n   */\n  [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    return (i + j + i * j % 3 & 0x01) === 0;\n  })]]);\n  return DataMask;\n}();\n\nexports.default = DataMask;","map":{"version":3,"mappings":"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","names":["DataMaskValues","exports","value","isMasked","DataMask","bits","dimension","i","j","flip","Map","DATA_MASK_000","DATA_MASK_001","DATA_MASK_010","DATA_MASK_011","DATA_MASK_100","Math","floor","DATA_MASK_101","DATA_MASK_110","DATA_MASK_111"],"sources":["../../../../src/core/qrcode/decoder/DataMask.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\n\nvar Version_1 = require(\"./Version\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @author bbrown@google.com (Brian Brown)\n */\n\n\nvar BitMatrixParser =\n/** @class */\nfunction () {\n  /**\n   * @param bitMatrix {@link BitMatrix} to parse\n   * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n\n    if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n      throw new FormatException_1.default();\n    }\n\n    this.version = BitMatrixParser.readVersion(bitMatrix);\n    this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n    this.readMappingMatrix = new BitMatrix_1.default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n  }\n\n  BitMatrixParser.prototype.getVersion = function () {\n    return this.version;\n  };\n  /**\n   * <p>Creates the version object based on the dimension of the original bit matrix from\n   * the datamatrix code.</p>\n   *\n   * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n   *\n   * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n   * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n   * @throws FormatException if the dimensions of the mapping matrix are not valid\n   * Data Matrix dimensions.\n   */\n\n\n  BitMatrixParser.readVersion = function (bitMatrix) {\n    var numRows = bitMatrix.getHeight();\n    var numColumns = bitMatrix.getWidth();\n    return Version_1.default.getVersionForDimensions(numRows, numColumns);\n  };\n  /**\n   * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n   * in the correct order in order to reconstitute the codewords bytes contained within the\n   * Data Matrix Code.</p>\n   *\n   * @return bytes encoded within the Data Matrix Code\n   * @throws FormatException if the exact number of bytes expected is not read\n   */\n\n\n  BitMatrixParser.prototype.readCodewords = function () {\n    var result = new Int8Array(this.version.getTotalCodewords());\n    var resultOffset = 0;\n    var row = 4;\n    var column = 0;\n    var numRows = this.mappingBitMatrix.getHeight();\n    var numColumns = this.mappingBitMatrix.getWidth();\n    var corner1Read = false;\n    var corner2Read = false;\n    var corner3Read = false;\n    var corner4Read = false; // Read all of the codewords\n\n    do {\n      // Check the four corner cases\n      if (row === numRows && column === 0 && !corner1Read) {\n        result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner1Read = true;\n      } else if (row === numRows - 2 && column === 0 && (numColumns & 0x03) !== 0 && !corner2Read) {\n        result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner2Read = true;\n      } else if (row === numRows + 4 && column === 2 && (numColumns & 0x07) === 0 && !corner3Read) {\n        result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner3Read = true;\n      } else if (row === numRows - 2 && column === 0 && (numColumns & 0x07) === 4 && !corner4Read) {\n        result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner4Read = true;\n      } else {\n        // Sweep upward diagonally to the right\n        do {\n          if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {\n            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n          }\n\n          row -= 2;\n          column += 2;\n        } while (row >= 0 && column < numColumns);\n\n        row += 1;\n        column += 3; // Sweep downward diagonally to the left\n\n        do {\n          if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {\n            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n          }\n\n          row += 2;\n          column -= 2;\n        } while (row < numRows && column >= 0);\n\n        row += 3;\n        column += 1;\n      }\n    } while (row < numRows || column < numColumns);\n\n    if (resultOffset !== this.version.getTotalCodewords()) {\n      throw new FormatException_1.default();\n    }\n\n    return result;\n  };\n  /**\n   * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n   *\n   * @param row Row to read in the mapping matrix\n   * @param column Column to read in the mapping matrix\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return value of the given bit in the mapping matrix\n   */\n\n\n  BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {\n    // Adjust the row and column indices based on boundary wrapping\n    if (row < 0) {\n      row += numRows;\n      column += 4 - (numRows + 4 & 0x07);\n    }\n\n    if (column < 0) {\n      column += numColumns;\n      row += 4 - (numColumns + 4 & 0x07);\n    }\n\n    this.readMappingMatrix.set(column, row);\n    return this.mappingBitMatrix.get(column, row);\n  };\n  /**\n   * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n   *\n   * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n   *\n   * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n   * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the utah shape\n   */\n\n\n  BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 1, column, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row, column, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 1.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.3</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 1\n   */\n\n\n  BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 2.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.4</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 2\n   */\n\n\n  BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 3.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.5</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 3\n   */\n\n\n  BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 4.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.6</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 4\n   */\n\n\n  BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Extracts the data region from a {@link BitMatrix} that contains\n   * alignment patterns.</p>\n   *\n   * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n   * @return BitMatrix that has the alignment patterns removed\n   */\n\n\n  BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {\n    var symbolSizeRows = this.version.getSymbolSizeRows();\n    var symbolSizeColumns = this.version.getSymbolSizeColumns();\n\n    if (bitMatrix.getHeight() !== symbolSizeRows) {\n      throw new IllegalArgumentException_1.default('Dimension of bitMatrix must match the version size');\n    }\n\n    var dataRegionSizeRows = this.version.getDataRegionSizeRows();\n    var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n    var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n    var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n    var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n    var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n    var bitMatrixWithoutAlignment = new BitMatrix_1.default(sizeDataRegionColumn, sizeDataRegionRow);\n\n    for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n      var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n\n      for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n        var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n\n        for (var i = 0; i < dataRegionSizeRows; ++i) {\n          var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n          var writeRowOffset = dataRegionRowOffset + i;\n\n          for (var j = 0; j < dataRegionSizeColumns; ++j) {\n            var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n\n            if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n              var writeColumnOffset = dataRegionColumnOffset + j;\n              bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n            }\n          }\n        }\n      }\n    }\n\n    return bitMatrixWithoutAlignment;\n  };\n\n  return BitMatrixParser;\n}();\n\nexports.default = BitMatrixParser;","map":{"version":3,"mappings":"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","names":["bitMatrix","dimension","getHeight","FormatException_1","version","BitMatrixParser","readVersion","mappingBitMatrix","extractDataRegion","readMappingMatrix","BitMatrix_1","getWidth","numRows","numColumns","Version_1","getVersionForDimensions","result","Int8Array","getTotalCodewords","resultOffset","row","column","corner1Read","corner2Read","corner3Read","corner4Read","readCorner1","readCorner2","readCorner3","readCorner4","get","readUtah","set","currentByte","readModule","symbolSizeRows","getSymbolSizeRows","symbolSizeColumns","getSymbolSizeColumns","IllegalArgumentException_1","dataRegionSizeRows","getDataRegionSizeRows","dataRegionSizeColumns","getDataRegionSizeColumns","numDataRegionsRow","numDataRegionsColumn","sizeDataRegionRow","sizeDataRegionColumn","bitMatrixWithoutAlignment","dataRegionRow","dataRegionRowOffset","dataRegionColumn","dataRegionColumnOffset","i","readRowOffset","writeRowOffset","j","readColumnOffset","writeColumnOffset"],"sources":["../../../../src/core/datamatrix/decoder/BitMatrixParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
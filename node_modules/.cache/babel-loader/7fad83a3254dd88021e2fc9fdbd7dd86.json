{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\nvar Binarizer_1 = require(\"../Binarizer\");\n\nvar BitArray_1 = require(\"./BitArray\");\n\nvar BitMatrix_1 = require(\"./BitMatrix\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n * and gradients.\n *\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\n\n\nvar GlobalHistogramBinarizer =\n/** @class */\nfunction (_super) {\n  __extends(GlobalHistogramBinarizer, _super);\n\n  function GlobalHistogramBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n\n    _this.luminances = GlobalHistogramBinarizer.EMPTY;\n    _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n    return _this;\n  } // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.getBlackRow = function (y\n  /*int*/\n  , row) {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n\n    if (row === undefined || row === null || row.getSize() < width) {\n      row = new BitArray_1.default(width);\n    } else {\n      row.clear();\n    }\n\n    this.initArrays(width);\n    var localLuminances = source.getRow(y, this.luminances);\n    var localBuckets = this.buckets;\n\n    for (var x = 0; x < width; x++) {\n      localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n    }\n\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n\n    if (width < 3) {\n      // Special case for very small images\n      for (var x = 0; x < width; x++) {\n        if ((localLuminances[x] & 0xff) < blackPoint) {\n          row.set(x);\n        }\n      }\n    } else {\n      var left = localLuminances[0] & 0xff;\n      var center = localLuminances[1] & 0xff;\n\n      for (var x = 1; x < width - 1; x++) {\n        var right = localLuminances[x + 1] & 0xff; // A simple -1 4 -1 box filter with a weight of 2.\n\n        if ((center * 4 - left - right) / 2 < blackPoint) {\n          row.set(x);\n        }\n\n        left = center;\n        center = right;\n      }\n    }\n\n    return row;\n  }; // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    var matrix = new BitMatrix_1.default(width, height); // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n    // more robust on the blackbox tests than sampling a diagonal as we used to do.\n\n    this.initArrays(width);\n    var localBuckets = this.buckets;\n\n    for (var y = 1; y < 5; y++) {\n      var row = Math.floor(height * y / 5);\n      var localLuminances_1 = source.getRow(row, this.luminances);\n      var right = Math.floor(width * 4 / 5);\n\n      for (var x = Math.floor(width / 5); x < right; x++) {\n        var pixel = localLuminances_1[x] & 0xff;\n        localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n      }\n    }\n\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets); // We delay reading the entire image luminance until the black point estimation succeeds.\n    // Although we end up reading four rows twice, it is consistent with our motto of\n    // \"fail quickly\" which is necessary for continuous scanning.\n\n    var localLuminances = source.getMatrix();\n\n    for (var y = 0; y < height; y++) {\n      var offset = y * width;\n\n      for (var x = 0; x < width; x++) {\n        var pixel = localLuminances[offset + x] & 0xff;\n\n        if (pixel < blackPoint) {\n          matrix.set(x, y);\n        }\n      }\n    }\n\n    return matrix;\n  };\n  /*@Override*/\n\n\n  GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n    return new GlobalHistogramBinarizer(source);\n  };\n\n  GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize\n  /*int*/\n  ) {\n    if (this.luminances.length < luminanceSize) {\n      this.luminances = new Uint8ClampedArray(luminanceSize);\n    }\n\n    var buckets = this.buckets;\n\n    for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n      buckets[x] = 0;\n    }\n  };\n\n  GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n    // Find the tallest peak in the histogram.\n    var numBuckets = buckets.length;\n    var maxBucketCount = 0;\n    var firstPeak = 0;\n    var firstPeakSize = 0;\n\n    for (var x = 0; x < numBuckets; x++) {\n      if (buckets[x] > firstPeakSize) {\n        firstPeak = x;\n        firstPeakSize = buckets[x];\n      }\n\n      if (buckets[x] > maxBucketCount) {\n        maxBucketCount = buckets[x];\n      }\n    } // Find the second-tallest peak which is somewhat far from the tallest peak.\n\n\n    var secondPeak = 0;\n    var secondPeakScore = 0;\n\n    for (var x = 0; x < numBuckets; x++) {\n      var distanceToBiggest = x - firstPeak; // Encourage more distant second peaks by multiplying by square of distance.\n\n      var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n\n      if (score > secondPeakScore) {\n        secondPeak = x;\n        secondPeakScore = score;\n      }\n    } // Make sure firstPeak corresponds to the black peak.\n\n\n    if (firstPeak > secondPeak) {\n      var temp = firstPeak;\n      firstPeak = secondPeak;\n      secondPeak = temp;\n    } // If there is too little contrast in the image to pick a meaningful black point, throw rather\n    // than waste time trying to decode the image, and risk false positives.\n\n\n    if (secondPeak - firstPeak <= numBuckets / 16) {\n      throw new NotFoundException_1.default();\n    } // Find a valley between them that is low and closer to the white peak.\n\n\n    var bestValley = secondPeak - 1;\n    var bestValleyScore = -1;\n\n    for (var x = secondPeak - 1; x > firstPeak; x--) {\n      var fromFirst = x - firstPeak;\n      var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n\n      if (score > bestValleyScore) {\n        bestValley = x;\n        bestValleyScore = score;\n      }\n    }\n\n    return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n  };\n\n  GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n  GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n  return GlobalHistogramBinarizer;\n}(Binarizer_1.default);\n\nexports.default = GlobalHistogramBinarizer;","map":{"version":3,"mappings":"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","names":["__extends","source","_super","_this","luminances","GlobalHistogramBinarizer","EMPTY","buckets","Int32Array","LUMINANCE_BUCKETS","y","row","getLuminanceSource","width","getWidth","undefined","getSize","BitArray_1","clear","initArrays","localLuminances","getRow","localBuckets","x","LUMINANCE_SHIFT","blackPoint","estimateBlackPoint","set","left","center","right","height","getHeight","matrix","BitMatrix_1","Math","floor","localLuminances_1","pixel","getMatrix","offset","luminanceSize","length","Uint8ClampedArray","numBuckets","maxBucketCount","firstPeak","firstPeakSize","secondPeak","secondPeakScore","distanceToBiggest","score","temp","NotFoundException_1","bestValley","bestValleyScore","fromFirst","LUMINANCE_BITS","from","Binarizer_1"],"sources":["../../../src/core/common/GlobalHistogramBinarizer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
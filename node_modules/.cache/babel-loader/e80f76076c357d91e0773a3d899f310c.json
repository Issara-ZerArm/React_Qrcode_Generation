{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\n/*import java.util.Arrays;*/\n\nvar System_1 = require(\"../util/System\");\n\nvar Integer_1 = require(\"../util/Integer\");\n\nvar Arrays_1 = require(\"../util/Arrays\");\n\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n *\n * @author Sean Owen\n */\n\n\nvar BitArray\n/*implements Cloneable*/\n=\n/** @class */\nfunction () {\n  // public constructor() {\n  //   this.size = 0\n  //   this.bits = new Int32Array(1)\n  // }\n  // public constructor(size?: number /*int*/) {\n  //   if (undefined === size) {\n  //     this.size = 0\n  //   } else {\n  //     this.size = size\n  //   }\n  //   this.bits = this.makeArray(size)\n  // }\n  // For testing only\n  function BitArray(size\n  /*int*/\n  , bits) {\n    if (undefined === size) {\n      this.size = 0;\n      this.bits = new Int32Array(1);\n    } else {\n      this.size = size;\n\n      if (undefined === bits || null === bits) {\n        this.bits = BitArray.makeArray(size);\n      } else {\n        this.bits = bits;\n      }\n    }\n  }\n\n  BitArray.prototype.getSize = function () {\n    return this.size;\n  };\n\n  BitArray.prototype.getSizeInBytes = function () {\n    return Math.floor((this.size + 7) / 8);\n  };\n\n  BitArray.prototype.ensureCapacity = function (size\n  /*int*/\n  ) {\n    if (size > this.bits.length * 32) {\n      var newBits = BitArray.makeArray(size);\n      System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n      this.bits = newBits;\n    }\n  };\n  /**\n   * @param i bit to get\n   * @return true iff bit i is set\n   */\n\n\n  BitArray.prototype.get = function (i\n  /*int*/\n  ) {\n    return (this.bits[Math.floor(i / 32)] & 1 << (i & 0x1F)) !== 0;\n  };\n  /**\n   * Sets bit i.\n   *\n   * @param i bit to set\n   */\n\n\n  BitArray.prototype.set = function (i\n  /*int*/\n  ) {\n    this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n  };\n  /**\n   * Flips bit i.\n   *\n   * @param i bit to set\n   */\n\n\n  BitArray.prototype.flip = function (i\n  /*int*/\n  ) {\n    this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n  };\n  /**\n   * @param from first bit to check\n   * @return index of first bit that is set, starting from the given index, or size if none are set\n   *  at or beyond this given index\n   * @see #getNextUnset(int)\n   */\n\n\n  BitArray.prototype.getNextSet = function (from\n  /*int*/\n  ) {\n    var size = this.size;\n\n    if (from >= size) {\n      return size;\n    }\n\n    var bits = this.bits;\n    var bitsOffset = Math.floor(from / 32);\n    var currentBits = bits[bitsOffset]; // mask off lesser bits first\n\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    var length = bits.length;\n\n    while (currentBits === 0) {\n      if (++bitsOffset === length) {\n        return size;\n      }\n\n      currentBits = bits[bitsOffset];\n    }\n\n    var result = bitsOffset * 32 + Integer_1.default.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  };\n  /**\n   * @param from index to start looking for unset bit\n   * @return index of next unset bit, or {@code size} if none are unset until the end\n   * @see #getNextSet(int)\n   */\n\n\n  BitArray.prototype.getNextUnset = function (from\n  /*int*/\n  ) {\n    var size = this.size;\n\n    if (from >= size) {\n      return size;\n    }\n\n    var bits = this.bits;\n    var bitsOffset = Math.floor(from / 32);\n    var currentBits = ~bits[bitsOffset]; // mask off lesser bits first\n\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    var length = bits.length;\n\n    while (currentBits === 0) {\n      if (++bitsOffset === length) {\n        return size;\n      }\n\n      currentBits = ~bits[bitsOffset];\n    }\n\n    var result = bitsOffset * 32 + Integer_1.default.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  };\n  /**\n   * Sets a block of 32 bits, starting at bit i.\n   *\n   * @param i first bit to set\n   * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n   * corresponds to bit i, the next-least-significant to i+1, and so on.\n   */\n\n\n  BitArray.prototype.setBulk = function (i\n  /*int*/\n  , newBits\n  /*int*/\n  ) {\n    this.bits[Math.floor(i / 32)] = newBits;\n  };\n  /**\n   * Sets a range of bits.\n   *\n   * @param start start of range, inclusive.\n   * @param end end of range, exclusive\n   */\n\n\n  BitArray.prototype.setRange = function (start\n  /*int*/\n  , end\n  /*int*/\n  ) {\n    if (end < start || start < 0 || end > this.size) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    if (end === start) {\n      return;\n    }\n\n    end--; // will be easier to treat this as the last actually set bit -- inclusive\n\n    var firstInt = Math.floor(start / 32);\n    var lastInt = Math.floor(end / 32);\n    var bits = this.bits;\n\n    for (var i = firstInt; i <= lastInt; i++) {\n      var firstBit = i > firstInt ? 0 : start & 0x1F;\n      var lastBit = i < lastInt ? 31 : end & 0x1F; // Ones from firstBit to lastBit, inclusive\n\n      var mask = (2 << lastBit) - (1 << firstBit);\n      bits[i] |= mask;\n    }\n  };\n  /**\n   * Clears all bits (sets to false).\n   */\n\n\n  BitArray.prototype.clear = function () {\n    var max = this.bits.length;\n    var bits = this.bits;\n\n    for (var i = 0; i < max; i++) {\n      bits[i] = 0;\n    }\n  };\n  /**\n   * Efficient method to check if a range of bits is set, or not set.\n   *\n   * @param start start of range, inclusive.\n   * @param end end of range, exclusive\n   * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n   * @return true iff all bits are set or not set in range, according to value argument\n   * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n   */\n\n\n  BitArray.prototype.isRange = function (start\n  /*int*/\n  , end\n  /*int*/\n  , value) {\n    if (end < start || start < 0 || end > this.size) {\n      throw new IllegalArgumentException_1.default();\n    }\n\n    if (end === start) {\n      return true; // empty range matches\n    }\n\n    end--; // will be easier to treat this as the last actually set bit -- inclusive\n\n    var firstInt = Math.floor(start / 32);\n    var lastInt = Math.floor(end / 32);\n    var bits = this.bits;\n\n    for (var i = firstInt; i <= lastInt; i++) {\n      var firstBit = i > firstInt ? 0 : start & 0x1F;\n      var lastBit = i < lastInt ? 31 : end & 0x1F; // Ones from firstBit to lastBit, inclusive\n\n      var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF; // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n      // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n\n      if ((bits[i] & mask) !== (value ? mask : 0)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  BitArray.prototype.appendBit = function (bit) {\n    this.ensureCapacity(this.size + 1);\n\n    if (bit) {\n      this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n    }\n\n    this.size++;\n  };\n  /**\n   * Appends the least-significant bits, from value, in order from most-significant to\n   * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n   * 0, 1, 1, 1, 1, 0 in that order.\n   *\n   * @param value {@code int} containing bits to append\n   * @param numBits bits from value to append\n   */\n\n\n  BitArray.prototype.appendBits = function (value\n  /*int*/\n  , numBits\n  /*int*/\n  ) {\n    if (numBits < 0 || numBits > 32) {\n      throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');\n    }\n\n    this.ensureCapacity(this.size + numBits);\n    var appendBit = this.appendBit;\n\n    for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n      this.appendBit((value >> numBitsLeft - 1 & 0x01) === 1);\n    }\n  };\n\n  BitArray.prototype.appendBitArray = function (other) {\n    var otherSize = other.size;\n    this.ensureCapacity(this.size + otherSize);\n    var appendBit = this.appendBit;\n\n    for (var i = 0; i < otherSize; i++) {\n      this.appendBit(other.get(i));\n    }\n  };\n\n  BitArray.prototype.xor = function (other) {\n    if (this.size !== other.size) {\n      throw new IllegalArgumentException_1.default('Sizes don\\'t match');\n    }\n\n    var bits = this.bits;\n\n    for (var i = 0, length_1 = bits.length; i < length_1; i++) {\n      // The last int could be incomplete (i.e. not have 32 bits in\n      // it) but there is no problem since 0 XOR 0 == 0.\n      bits[i] ^= other.bits[i];\n    }\n  };\n  /**\n   *\n   * @param bitOffset first bit to start writing\n   * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n   *  of the internal representation, which is exposed by {@link #getBitArray()}\n   * @param offset position in array to start writing\n   * @param numBytes how many bytes to write\n   */\n\n\n  BitArray.prototype.toBytes = function (bitOffset\n  /*int*/\n  , array, offset\n  /*int*/\n  , numBytes\n  /*int*/\n  ) {\n    for (var i = 0; i < numBytes; i++) {\n      var theByte = 0;\n\n      for (var j = 0; j < 8; j++) {\n        if (this.get(bitOffset)) {\n          theByte |= 1 << 7 - j;\n        }\n\n        bitOffset++;\n      }\n\n      array[offset + i] =\n      /*(byte)*/\n      theByte;\n    }\n  };\n  /**\n   * @return underlying array of ints. The first element holds the first 32 bits, and the least\n   *         significant bit is bit 0.\n   */\n\n\n  BitArray.prototype.getBitArray = function () {\n    return this.bits;\n  };\n  /**\n   * Reverses all bits in the array.\n   */\n\n\n  BitArray.prototype.reverse = function () {\n    var newBits = new Int32Array(this.bits.length); // reverse all int's first\n\n    var len = Math.floor((this.size - 1) / 32);\n    var oldBitsLen = len + 1;\n    var bits = this.bits;\n\n    for (var i = 0; i < oldBitsLen; i++) {\n      var x = bits[i];\n      x = x >> 1 & 0x55555555 | (x & 0x55555555) << 1;\n      x = x >> 2 & 0x33333333 | (x & 0x33333333) << 2;\n      x = x >> 4 & 0x0f0f0f0f | (x & 0x0f0f0f0f) << 4;\n      x = x >> 8 & 0x00ff00ff | (x & 0x00ff00ff) << 8;\n      x = x >> 16 & 0x0000ffff | (x & 0x0000ffff) << 16;\n      newBits[len - i] =\n      /*(int)*/\n      x;\n    } // now correct the int's if the bit size isn't a multiple of 32\n\n\n    if (this.size !== oldBitsLen * 32) {\n      var leftOffset = oldBitsLen * 32 - this.size;\n      var currentInt = newBits[0] >>> leftOffset;\n\n      for (var i = 1; i < oldBitsLen; i++) {\n        var nextInt = newBits[i];\n        currentInt |= nextInt << 32 - leftOffset;\n        newBits[i - 1] = currentInt;\n        currentInt = nextInt >>> leftOffset;\n      }\n\n      newBits[oldBitsLen - 1] = currentInt;\n    }\n\n    this.bits = newBits;\n  };\n\n  BitArray.makeArray = function (size\n  /*int*/\n  ) {\n    return new Int32Array(Math.floor((size + 31) / 32));\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.equals = function (o) {\n    if (!(o instanceof BitArray)) {\n      return false;\n    }\n\n    var other = o;\n    return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.hashCode = function () {\n    return 31 * this.size + Arrays_1.default.hashCode(this.bits);\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.toString = function () {\n    var result = '';\n\n    for (var i = 0, size = this.size; i < size; i++) {\n      if ((i & 0x07) === 0) {\n        result += ' ';\n      }\n\n      result += this.get(i) ? 'X' : '.';\n    }\n\n    return result;\n  };\n  /*@Override*/\n\n\n  BitArray.prototype.clone = function () {\n    return new BitArray(this.size, this.bits.slice());\n  };\n\n  return BitArray;\n}();\n\nexports.default = BitArray;","map":{"version":3,"mappings":"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","names":["size","bits","undefined","Int32Array","BitArray","makeArray","Math","floor","length","newBits","System_1","arraycopy","i","from","bitsOffset","currentBits","result","Integer_1","numberOfTrailingZeros","start","end","IllegalArgumentException_1","firstInt","lastInt","firstBit","lastBit","mask","max","value","bit","ensureCapacity","numBits","appendBit","numBitsLeft","other","otherSize","get","length_1","bitOffset","array","offset","numBytes","theByte","j","len","oldBitsLen","x","leftOffset","currentInt","nextInt","o","Arrays_1","equals","hashCode","slice"],"sources":["../../../src/core/common/BitArray.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
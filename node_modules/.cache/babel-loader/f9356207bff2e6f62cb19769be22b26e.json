{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common.detector {*/\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar MathUtils_1 = require(\"./MathUtils\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\n\n\nvar WhiteRectangleDetector =\n/** @class */\nfunction () {\n  // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n  //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n  // }\n\n  /**\n   * @param image barcode image to find a rectangle in\n   * @param initSize initial size of search area around center\n   * @param x x position of search center\n   * @param y y position of search center\n   * @throws NotFoundException if image is too small to accommodate {@code initSize}\n   */\n  function WhiteRectangleDetector(image, initSize\n  /*int*/\n  , x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    this.image = image;\n    this.height = image.getHeight();\n    this.width = image.getWidth();\n\n    if (undefined === initSize || null === initSize) {\n      initSize = WhiteRectangleDetector.INIT_SIZE;\n    }\n\n    if (undefined === x || null === x) {\n      x = image.getWidth() / 2 | 0;\n    }\n\n    if (undefined === y || null === y) {\n      y = image.getHeight() / 2 | 0;\n    }\n\n    var halfsize = initSize / 2 | 0;\n    this.leftInit = x - halfsize;\n    this.rightInit = x + halfsize;\n    this.upInit = y - halfsize;\n    this.downInit = y + halfsize;\n\n    if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n      throw new NotFoundException_1.default();\n    }\n  }\n  /**\n   * <p>\n   * Detects a candidate barcode-like rectangular region within an image. It\n   * starts around the center of the image, increases the size of the candidate\n   * region until it finds a white rectangular region.\n   * </p>\n   *\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */\n\n\n  WhiteRectangleDetector.prototype.detect = function () {\n    var left = this.leftInit;\n    var right = this.rightInit;\n    var up = this.upInit;\n    var down = this.downInit;\n    var sizeExceeded = false;\n    var aBlackPointFoundOnBorder = true;\n    var atLeastOneBlackPointFoundOnBorder = false;\n    var atLeastOneBlackPointFoundOnRight = false;\n    var atLeastOneBlackPointFoundOnBottom = false;\n    var atLeastOneBlackPointFoundOnLeft = false;\n    var atLeastOneBlackPointFoundOnTop = false;\n    var width = this.width;\n    var height = this.height;\n\n    while (aBlackPointFoundOnBorder) {\n      aBlackPointFoundOnBorder = false; // .....\n      // .   |\n      // .....\n\n      var rightBorderNotWhite = true;\n\n      while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n        rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n\n        if (rightBorderNotWhite) {\n          right++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnRight = true;\n        } else if (!atLeastOneBlackPointFoundOnRight) {\n          right++;\n        }\n      }\n\n      if (right >= width) {\n        sizeExceeded = true;\n        break;\n      } // .....\n      // .   .\n      // .___.\n\n\n      var bottomBorderNotWhite = true;\n\n      while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n        bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n\n        if (bottomBorderNotWhite) {\n          down++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnBottom = true;\n        } else if (!atLeastOneBlackPointFoundOnBottom) {\n          down++;\n        }\n      }\n\n      if (down >= height) {\n        sizeExceeded = true;\n        break;\n      } // .....\n      // |   .\n      // .....\n\n\n      var leftBorderNotWhite = true;\n\n      while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n        leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n\n        if (leftBorderNotWhite) {\n          left--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnLeft = true;\n        } else if (!atLeastOneBlackPointFoundOnLeft) {\n          left--;\n        }\n      }\n\n      if (left < 0) {\n        sizeExceeded = true;\n        break;\n      } // .___.\n      // .   .\n      // .....\n\n\n      var topBorderNotWhite = true;\n\n      while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n        topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n\n        if (topBorderNotWhite) {\n          up--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnTop = true;\n        } else if (!atLeastOneBlackPointFoundOnTop) {\n          up--;\n        }\n      }\n\n      if (up < 0) {\n        sizeExceeded = true;\n        break;\n      }\n\n      if (aBlackPointFoundOnBorder) {\n        atLeastOneBlackPointFoundOnBorder = true;\n      }\n    }\n\n    if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n      var maxSize = right - left;\n      var z = null;\n\n      for (var i = 1; z === null && i < maxSize; i++) {\n        z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n      }\n\n      if (z == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var t = null; // go down right\n\n      for (var i = 1; t === null && i < maxSize; i++) {\n        t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n      }\n\n      if (t == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var x = null; // go down left\n\n      for (var i = 1; x === null && i < maxSize; i++) {\n        x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n      }\n\n      if (x == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      var y = null; // go up left\n\n      for (var i = 1; y === null && i < maxSize; i++) {\n        y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n      }\n\n      if (y == null) {\n        throw new NotFoundException_1.default();\n      }\n\n      return this.centerEdges(y, z, x, t);\n    } else {\n      throw new NotFoundException_1.default();\n    }\n  };\n\n  WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX\n  /*float*/\n  , aY\n  /*float*/\n  , bX\n  /*float*/\n  , bY\n  /*float*/\n  ) {\n    var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n    var xStep = (bX - aX) / dist;\n    var yStep = (bY - aY) / dist;\n    var image = this.image;\n\n    for (var i = 0; i < dist; i++) {\n      var x = MathUtils_1.default.round(aX + i * xStep);\n      var y = MathUtils_1.default.round(aY + i * yStep);\n\n      if (image.get(x, y)) {\n        return new ResultPoint_1.default(x, y);\n      }\n    }\n\n    return null;\n  };\n  /**\n   * recenters the points of a constant distance towards the center\n   *\n   * @param y bottom most point\n   * @param z left most point\n   * @param x right most point\n   * @param t top most point\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   */\n\n\n  WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n    //\n    //       t            t\n    //  z                      x\n    //        x    OR    z\n    //   y                    y\n    //\n    var yi = y.getX();\n    var yj = y.getY();\n    var zi = z.getX();\n    var zj = z.getY();\n    var xi = x.getX();\n    var xj = x.getY();\n    var ti = t.getX();\n    var tj = t.getY();\n    var CORR = WhiteRectangleDetector.CORR;\n\n    if (yi < this.width / 2.0) {\n      return [new ResultPoint_1.default(ti - CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj + CORR), new ResultPoint_1.default(xi - CORR, xj - CORR), new ResultPoint_1.default(yi + CORR, yj - CORR)];\n    } else {\n      return [new ResultPoint_1.default(ti + CORR, tj + CORR), new ResultPoint_1.default(zi + CORR, zj - CORR), new ResultPoint_1.default(xi - CORR, xj + CORR), new ResultPoint_1.default(yi - CORR, yj - CORR)];\n    }\n  };\n  /**\n   * Determines whether a segment contains a black point\n   *\n   * @param a          min value of the scanned coordinate\n   * @param b          max value of the scanned coordinate\n   * @param fixed      value of fixed coordinate\n   * @param horizontal set to true if scan must be horizontal, false if vertical\n   * @return true if a black point has been found, else false.\n   */\n\n\n  WhiteRectangleDetector.prototype.containsBlackPoint = function (a\n  /*int*/\n  , b\n  /*int*/\n  , fixed\n  /*int*/\n  , horizontal) {\n    var image = this.image;\n\n    if (horizontal) {\n      for (var x = a; x <= b; x++) {\n        if (image.get(x, fixed)) {\n          return true;\n        }\n      }\n    } else {\n      for (var y = a; y <= b; y++) {\n        if (image.get(fixed, y)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  WhiteRectangleDetector.INIT_SIZE = 10;\n  WhiteRectangleDetector.CORR = 1;\n  return WhiteRectangleDetector;\n}();\n\nexports.default = WhiteRectangleDetector;","map":{"version":3,"mappings":"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","names":["image","initSize","x","y","height","getHeight","width","getWidth","undefined","WhiteRectangleDetector","INIT_SIZE","halfsize","leftInit","rightInit","upInit","downInit","NotFoundException_1","left","right","up","down","sizeExceeded","aBlackPointFoundOnBorder","atLeastOneBlackPointFoundOnBorder","atLeastOneBlackPointFoundOnRight","atLeastOneBlackPointFoundOnBottom","atLeastOneBlackPointFoundOnLeft","atLeastOneBlackPointFoundOnTop","rightBorderNotWhite","containsBlackPoint","bottomBorderNotWhite","leftBorderNotWhite","topBorderNotWhite","maxSize","z","i","getBlackPointOnSegment","t","centerEdges","aX","aY","bX","bY","dist","MathUtils_1","round","distance","xStep","yStep","get","ResultPoint_1","yi","getX","yj","getY","zi","zj","xi","xj","ti","tj","CORR","a","b","fixed","horizontal"],"sources":["../../../../src/core/common/detector/WhiteRectangleDetector.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.ChecksumException;\n\nvar ChecksumException_1 = require(\"../../ChecksumException\"); // import com.google.zxing.FormatException;\n\n\nvar FormatException_1 = require(\"../../FormatException\"); // import com.google.zxing.NotFoundException;\n\n\nvar NotFoundException_1 = require(\"../../NotFoundException\"); // import com.google.zxing.common.detector.MathUtils;\n\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\"); // import com.google.zxing.pdf417.PDF417Common;\n\n\nvar PDF417Common_1 = require(\"../PDF417Common\"); // import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;\n\n\nvar ErrorCorrection_1 = require(\"./ec/ErrorCorrection\"); // local\n\n\nvar BoundingBox_1 = require(\"./BoundingBox\");\n\nvar DetectionResultRowIndicatorColumn_1 = require(\"./DetectionResultRowIndicatorColumn\");\n\nvar DetectionResult_1 = require(\"./DetectionResult\");\n\nvar DetectionResultColumn_1 = require(\"./DetectionResultColumn\");\n\nvar Codeword_1 = require(\"./Codeword\");\n\nvar BarcodeValue_1 = require(\"./BarcodeValue\");\n\nvar PDF417CodewordDecoder_1 = require(\"./PDF417CodewordDecoder\");\n\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\"); // utils\n\n\nvar Formatter_1 = require(\"../../util/Formatter\"); // import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.Formatter;\n// import java.util.List;\n\n/**\n * @author Guenther Grau\n */\n\n\nvar PDF417ScanningDecoder =\n/** @class */\nfunction () {\n  function PDF417ScanningDecoder() {}\n  /**\n   * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n   *\n   * columns. That way width can be deducted from the pattern column.\n   * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n   * than it should be. This can happen if the scanner used a bad blackpoint.\n   *\n   * @param BitMatrix\n   * @param image\n   * @param ResultPoint\n   * @param imageTopLeft\n   * @param ResultPoint\n   * @param imageBottomLeft\n   * @param ResultPoint\n   * @param imageTopRight\n   * @param ResultPoint\n   * @param imageBottomRight\n   * @param int\n   * @param minCodewordWidth\n   * @param int\n   * @param maxCodewordWidth\n   *\n   * @throws NotFoundException\n   * @throws FormatException\n   * @throws ChecksumException\n   */\n\n\n  PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n    var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n    var leftRowIndicatorColumn = null;\n    var rightRowIndicatorColumn = null;\n    var detectionResult;\n\n    for (var firstPass\n    /*boolean*/\n    = true;; firstPass = false) {\n      if (imageTopLeft != null) {\n        leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n      }\n\n      if (imageTopRight != null) {\n        rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n      }\n\n      detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n\n      if (detectionResult == null) {\n        throw NotFoundException_1.default.getNotFoundInstance();\n      }\n\n      var resultBox = detectionResult.getBoundingBox();\n\n      if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n        boundingBox = resultBox;\n      } else {\n        break;\n      }\n    }\n\n    detectionResult.setBoundingBox(boundingBox);\n    var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n    detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n    detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n    var leftToRight = leftRowIndicatorColumn != null;\n\n    for (var barcodeColumnCount\n    /*int*/\n    = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n      var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n\n      if (detectionResult.getDetectionResultColumn(barcodeColumn) !==\n      /* null */\n      undefined) {\n        // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n        continue;\n      }\n\n      var detectionResultColumn = void 0;\n\n      if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n        detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);\n      } else {\n        detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);\n      }\n\n      detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n      var startColumn = -1;\n      var previousStartColumn = startColumn; // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n\n      for (var imageRow\n      /*int*/\n      = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n        startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n\n        if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n          if (previousStartColumn === -1) {\n            continue;\n          }\n\n          startColumn = previousStartColumn;\n        }\n\n        var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n\n        if (codeword != null) {\n          detectionResultColumn.setCodeword(imageRow, codeword);\n          previousStartColumn = startColumn;\n          minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n          maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n        }\n      }\n    }\n\n    return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n  };\n  /**\n   *\n   * @param leftRowIndicatorColumn\n   * @param rightRowIndicatorColumn\n   *\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n    if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n      return null;\n    }\n\n    var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n\n    if (barcodeMetadata == null) {\n      return null;\n    }\n\n    var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n    return new DetectionResult_1.default(barcodeMetadata, boundingBox);\n  };\n  /**\n   *\n   * @param rowIndicatorColumn\n   *\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {\n    var e_1, _a;\n\n    if (rowIndicatorColumn == null) {\n      return null;\n    }\n\n    var rowHeights = rowIndicatorColumn.getRowHeights();\n\n    if (rowHeights == null) {\n      return null;\n    }\n\n    var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n    var missingStartRows = 0;\n\n    try {\n      for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {\n        var rowHeight = rowHeights_1_1.value\n        /*int*/\n        ;\n        missingStartRows += maxRowHeight - rowHeight;\n\n        if (rowHeight > 0) {\n          break;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var codewords = rowIndicatorColumn.getCodewords();\n\n    for (var row\n    /*int*/\n    = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n      missingStartRows--;\n    }\n\n    var missingEndRows = 0;\n\n    for (var row\n    /*int*/\n    = rowHeights.length - 1; row >= 0; row--) {\n      missingEndRows += maxRowHeight - rowHeights[row];\n\n      if (rowHeights[row] > 0) {\n        break;\n      }\n    }\n\n    for (var row\n    /*int*/\n    = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n      missingEndRows--;\n    }\n\n    return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n  };\n\n  PDF417ScanningDecoder.getMax = function (values) {\n    var e_2, _a;\n\n    var maxValue = -1;\n\n    try {\n      for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n        var value = values_1_1.value\n        /*int*/\n        ;\n        maxValue = Math.max(maxValue, value);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return maxValue;\n  };\n\n  PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n    var leftBarcodeMetadata;\n\n    if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n      return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n    }\n\n    var rightBarcodeMetadata;\n\n    if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n      return leftBarcodeMetadata;\n    }\n\n    if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n      return null;\n    }\n\n    return leftBarcodeMetadata;\n  };\n\n  PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n    var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);\n\n    for (var i\n    /*int*/\n    = 0; i < 2; i++) {\n      var increment = i === 0 ? 1 : -1;\n      var startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n\n      for (var imageRow\n      /*int*/\n      = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {\n        var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n\n        if (codeword != null) {\n          rowIndicatorColumn.setCodeword(imageRow, codeword);\n\n          if (leftToRight) {\n            startColumn = codeword.getStartX();\n          } else {\n            startColumn = codeword.getEndX();\n          }\n        }\n      }\n    }\n\n    return rowIndicatorColumn;\n  };\n  /**\n   *\n   * @param detectionResult\n   * @param BarcodeValue\n   * @param param2\n   * @param param3\n   * @param barcodeMatrix\n   *\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {\n    var barcodeMatrix01 = barcodeMatrix[0][1];\n    var numberOfCodewords = barcodeMatrix01.getValue();\n    var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n\n    if (numberOfCodewords.length === 0) {\n      if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {\n        throw NotFoundException_1.default.getNotFoundInstance();\n      }\n\n      barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n    } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n      // The calculated one is more reliable as it is derived from the row indicator columns\n      barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n    }\n  };\n  /**\n   *\n   * @param detectionResult\n   *\n   * @throws FormatException\n   * @throws ChecksumException\n   * @throws NotFoundException\n   */\n\n\n  PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {\n    var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n    PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n    var erasures\n    /*Collection<Integer>*/\n    = new Array();\n    var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n    var ambiguousIndexValuesList =\n    /*List<int[]>*/\n    [];\n    var ambiguousIndexesList =\n    /*Collection<Integer>*/\n    new Array();\n\n    for (var row\n    /*int*/\n    = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n      for (var column\n      /*int*/\n      = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n        var values = barcodeMatrix[row][column + 1].getValue();\n        var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n\n        if (values.length === 0) {\n          erasures.push(codewordIndex);\n        } else if (values.length === 1) {\n          codewords[codewordIndex] = values[0];\n        } else {\n          ambiguousIndexesList.push(codewordIndex);\n          ambiguousIndexValuesList.push(values);\n        }\n      }\n    }\n\n    var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n\n    for (var i\n    /*int*/\n    = 0; i < ambiguousIndexValues.length; i++) {\n      ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n    }\n\n    return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n  };\n  /**\n   * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n   * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n   * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n   * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n   * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n   * so decoding the normal barcodes is not affected by this.\n   *\n   * @param erasureArray contains the indexes of erasures\n   * @param ambiguousIndexes array with the indexes that have more than one most likely value\n   * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n   * be the same length as the ambiguousIndexes array\n   *\n   * @throws FormatException\n   * @throws ChecksumException\n   */\n\n\n  PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n    var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n    var tries = 100;\n\n    while (tries-- > 0) {\n      for (var i\n      /*int*/\n      = 0; i < ambiguousIndexCount.length; i++) {\n        codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n      }\n\n      try {\n        return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n      } catch (err) {\n        var ignored = err instanceof ChecksumException_1.default;\n\n        if (!ignored) {\n          throw err;\n        }\n      }\n\n      if (ambiguousIndexCount.length === 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      for (var i\n      /*int*/\n      = 0; i < ambiguousIndexCount.length; i++) {\n        if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n          ambiguousIndexCount[i]++;\n          break;\n        } else {\n          ambiguousIndexCount[i] = 0;\n\n          if (i === ambiguousIndexCount.length - 1) {\n            throw ChecksumException_1.default.getChecksumInstance();\n          }\n        }\n      }\n    }\n\n    throw ChecksumException_1.default.getChecksumInstance();\n  };\n\n  PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {\n    var e_3, _a, e_4, _b; // let barcodeMatrix: BarcodeValue[][] =\n    // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n\n\n    var barcodeMatrix = Array.from({\n      length: detectionResult.getBarcodeRowCount()\n    }, function () {\n      return new Array(detectionResult.getBarcodeColumnCount() + 2);\n    });\n\n    for (var row\n    /*int*/\n    = 0; row < barcodeMatrix.length; row++) {\n      for (var column_1\n      /*int*/\n      = 0; column_1 < barcodeMatrix[row].length; column_1++) {\n        barcodeMatrix[row][column_1] = new BarcodeValue_1.default();\n      }\n    }\n\n    var column = 0;\n\n    try {\n      for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var detectionResultColumn = _d.value\n        /*DetectionResultColumn*/\n        ;\n\n        if (detectionResultColumn != null) {\n          try {\n            for (var _e = __values(detectionResultColumn.getCodewords()), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var codeword = _f.value\n              /*Codeword*/\n              ;\n\n              if (codeword != null) {\n                var rowNumber = codeword.getRowNumber();\n\n                if (rowNumber >= 0) {\n                  if (rowNumber >= barcodeMatrix.length) {\n                    // We have more rows than the barcode metadata allows for, ignore them.\n                    continue;\n                  }\n\n                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                }\n              }\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n\n        column++;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return barcodeMatrix;\n  };\n\n  PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {\n    return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n  };\n\n  PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {\n    var e_5, _a;\n\n    var offset = leftToRight ? 1 : -1;\n    var codeword = null;\n\n    if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n    }\n\n    if (codeword != null) {\n      return leftToRight ? codeword.getEndX() : codeword.getStartX();\n    }\n\n    codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n\n    if (codeword != null) {\n      return leftToRight ? codeword.getStartX() : codeword.getEndX();\n    }\n\n    if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n    }\n\n    if (codeword != null) {\n      return leftToRight ? codeword.getEndX() : codeword.getStartX();\n    }\n\n    var skippedColumns = 0;\n\n    while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n      barcodeColumn -= offset;\n\n      try {\n        for (var _b = __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var previousRowCodeword = _c.value\n          /*Codeword*/\n          ;\n\n          if (previousRowCodeword != null) {\n            return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      skippedColumns++;\n    }\n\n    return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n  };\n\n  PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n    startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow); // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n    // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n    // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n    // for the current position\n\n    var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n\n    if (moduleBitCount == null) {\n      return null;\n    }\n\n    var endColumn;\n    var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);\n\n    if (leftToRight) {\n      endColumn = startColumn + codewordBitCount;\n    } else {\n      for (var i\n      /*int*/\n      = 0; i < moduleBitCount.length / 2; i++) {\n        var tmpCount = moduleBitCount[i];\n        moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n        moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n      }\n\n      endColumn = startColumn;\n      startColumn = endColumn - codewordBitCount;\n    } // TODO implement check for width and correction of black and white bars\n    // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n    // should probably done only for codewords with a lot more than 17 bits.\n    // The following fixes 10-1.png, which has wide black bars and small white bars\n    //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n    //      if (i % 2 === 0) {\n    //        moduleBitCount[i]--;\n    //      } else {\n    //        moduleBitCount[i]++;\n    //      }\n    //    }\n    // We could also use the width of surrounding codewords for more accurate results, but this seems\n    // sufficient for now\n\n\n    if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n      // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n      // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n      return null;\n    }\n\n    var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);\n    var codeword = PDF417Common_1.default.getCodeword(decodedValue);\n\n    if (codeword === -1) {\n      return null;\n    }\n\n    return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n  };\n\n  PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n    var imageColumn = startColumn;\n    var moduleBitCount = new Int32Array(8);\n    var moduleNumber = 0;\n    var increment = leftToRight ? 1 : -1;\n    var previousPixelValue = leftToRight;\n\n    while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {\n      if (image.get(imageColumn, imageRow) === previousPixelValue) {\n        moduleBitCount[moduleNumber]++;\n        imageColumn += increment;\n      } else {\n        moduleNumber++;\n        previousPixelValue = !previousPixelValue;\n      }\n    }\n\n    if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {\n      return moduleBitCount;\n    }\n\n    return null;\n  };\n\n  PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {\n    return 2 << barcodeECLevel;\n  };\n\n  PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n    var correctedStartColumn = codewordStartColumn;\n    var increment = leftToRight ? -1 : 1; // there should be no black pixels before the start column. If there are, then we need to start earlier.\n\n    for (var i\n    /*int*/\n    = 0; i < 2; i++) {\n      while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {\n        if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n          return codewordStartColumn;\n        }\n\n        correctedStartColumn += increment;\n      }\n\n      increment = -increment;\n      leftToRight = !leftToRight;\n    }\n\n    return correctedStartColumn;\n  };\n\n  PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {\n    return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n  };\n  /**\n   * @throws FormatException,\n   * @throws ChecksumException\n   */\n\n\n  PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {\n    if (codewords.length === 0) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    var numECCodewords = 1 << ecLevel + 1;\n    var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n    PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords); // Decode the codewords\n\n    var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);\n    decoderResult.setErrorsCorrected(correctedErrorsCount);\n    decoderResult.setErasures(erasures.length);\n    return decoderResult;\n  };\n  /**\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n   * correct the errors in-place.</p>\n   *\n   * @param codewords   data and error correction codewords\n   * @param erasures positions of any known erasures\n   * @param numECCodewords number of error correction codewords that are available in codewords\n   * @throws ChecksumException if error correction fails\n   */\n\n\n  PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {\n    if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n      // Too many errors or EC Codewords is corrupted\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n  };\n  /**\n   * Verify that all is OK with the codeword array.\n   * @throws FormatException\n   */\n\n\n  PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {\n    if (codewords.length < 4) {\n      // Codeword array size should be at least 4 allowing for\n      // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n      throw FormatException_1.default.getFormatInstance();\n    } // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n    // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n    // codewords, but excluding the number of error correction codewords.\n\n\n    var numberOfCodewords = codewords[0];\n\n    if (numberOfCodewords > codewords.length) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    if (numberOfCodewords === 0) {\n      // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n      if (numECCodewords < codewords.length) {\n        codewords[0] = codewords.length - numECCodewords;\n      } else {\n        throw FormatException_1.default.getFormatInstance();\n      }\n    }\n  };\n\n  PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {\n    var result = new Int32Array(8);\n    var previousValue = 0;\n    var i = result.length - 1;\n\n    while (true) {\n      if ((codeword & 0x1) !== previousValue) {\n        previousValue = codeword & 0x1;\n        i--;\n\n        if (i < 0) {\n          break;\n        }\n      }\n\n      result[i]++;\n      codeword >>= 1;\n    }\n\n    return result;\n  };\n\n  PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {\n    if (codeword instanceof Int32Array) {\n      return this.getCodewordBucketNumber_Int32Array(codeword);\n    }\n\n    return this.getCodewordBucketNumber_number(codeword);\n  };\n\n  PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {\n    return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n  };\n\n  PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {\n    return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n  };\n\n  PDF417ScanningDecoder.toString = function (barcodeMatrix) {\n    var formatter = new Formatter_1.default(); // try (let formatter = new Formatter()) {\n\n    for (var row\n    /*int*/\n    = 0; row < barcodeMatrix.length; row++) {\n      formatter.format('Row %2d: ', row);\n\n      for (var column\n      /*int*/\n      = 0; column < barcodeMatrix[row].length; column++) {\n        var barcodeValue = barcodeMatrix[row][column];\n\n        if (barcodeValue.getValue().length === 0) {\n          formatter.format('        ', null);\n        } else {\n          formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n        }\n      }\n\n      formatter.format('%n');\n    }\n\n    return formatter.toString(); // }\n  };\n  /*final*/\n\n\n  PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n  /*final*/\n\n  PDF417ScanningDecoder.MAX_ERRORS = 3;\n  /*final*/\n\n  PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n  /*final*/\n\n  PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();\n  return PDF417ScanningDecoder;\n}();\n\nexports.default = PDF417ScanningDecoder;","map":{"version":3,"mappings":"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","names":["PDF417ScanningDecoder","image","imageTopLeft","imageBottomLeft","imageTopRight","imageBottomRight","minCodewordWidth","maxCodewordWidth","boundingBox","BoundingBox_1","leftRowIndicatorColumn","rightRowIndicatorColumn","detectionResult","firstPass","getRowIndicatorColumn","merge","NotFoundException_1","getNotFoundInstance","resultBox","getBoundingBox","getMinY","getMaxY","setBoundingBox","maxBarcodeColumn","getBarcodeColumnCount","setDetectionResultColumn","leftToRight","barcodeColumnCount","barcodeColumn","getDetectionResultColumn","undefined","detectionResultColumn","DetectionResultRowIndicatorColumn_1","DetectionResultColumn_1","startColumn","previousStartColumn","imageRow","getStartColumn","getMaxX","codeword","detectCodeword","getMinX","setCodeword","Math","min","getWidth","max","createDecoderResult","barcodeMetadata","getBarcodeMetadata","adjustBoundingBox","DetectionResult_1","rowIndicatorColumn","rowHeights","getRowHeights","maxRowHeight","getMax","missingStartRows","rowHeights_1_1","rowHeight","codewords","getCodewords","row","missingEndRows","length","addMissingRows","isLeft","values","maxValue","values_1_1","value","leftBarcodeMetadata","rightBarcodeMetadata","getColumnCount","getErrorCorrectionLevel","getRowCount","startPoint","i","increment","trunc","getX","getY","getStartX","getEndX","barcodeMatrix","barcodeMatrix01","numberOfCodewords","getValue","calculatedNumberOfCodewords","getBarcodeRowCount","getNumberOfECCodeWords","getBarcodeECLevel","PDF417Common_1","MAX_CODEWORDS_IN_BARCODE","setValue","createBarcodeMatrix","adjustCodewordCount","erasures","Array","Int32Array","ambiguousIndexValuesList","ambiguousIndexesList","column","codewordIndex","push","ambiguousIndexValues","createDecoderResultFromAmbiguousValues","toIntArray","ecLevel","erasureArray","ambiguousIndexes","ambiguousIndexCount","tries","decodeCodewords","err","ignored","ChecksumException_1","getChecksumInstance","from","column_1","BarcodeValue_1","getDetectionResultColumns","_d","_f","rowNumber","getRowNumber","offset","isValidBarcodeColumn","getCodeword","getCodewordNearby","skippedColumns","_c","previousRowCodeword","minColumn","maxColumn","adjustCodewordStartColumn","moduleBitCount","getModuleBitCount","endColumn","codewordBitCount","MathUtils_1","sum","tmpCount","checkCodewordSkew","decodedValue","PDF417CodewordDecoder_1","getDecodedValue","Codeword_1","getCodewordBucketNumber","imageColumn","moduleNumber","previousPixelValue","get","barcodeECLevel","codewordStartColumn","correctedStartColumn","abs","CODEWORD_SKEW_SIZE","codewordSize","FormatException_1","getFormatInstance","numECCodewords","correctedErrorsCount","correctErrors","verifyCodewordCount","decoderResult","DecodedBitStreamParser_1","decode","setErrorsCorrected","setErasures","MAX_ERRORS","MAX_EC_CODEWORDS","errorCorrection","result","previousValue","getCodewordBucketNumber_Int32Array","getCodewordBucketNumber_number","getBitCountForCodeword","formatter","Formatter_1","format","barcodeValue","getConfidence","toString","ErrorCorrection_1"],"sources":["../../../../src/core/pdf417/decoder/PDF417ScanningDecoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode {*/\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar Result_1 = require(\"../Result\");\n\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\n\nvar Decoder_1 = require(\"./decoder/Decoder\");\n\nvar QRCodeDecoderMetaData_1 = require(\"./decoder/QRCodeDecoderMetaData\");\n\nvar Detector_1 = require(\"./detector/Detector\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/*import java.util.List;*/\n\n/*import java.util.Map;*/\n\n/**\n * This implementation can detect and decode QR Codes in an image.\n *\n * @author Sean Owen\n */\n\n\nvar QRCodeReader =\n/** @class */\nfunction () {\n  function QRCodeReader() {\n    this.decoder = new Decoder_1.default();\n  }\n\n  QRCodeReader.prototype.getDecoder = function () {\n    return this.decoder;\n  };\n  /**\n   * Locates and decodes a QR code in an image.\n   *\n   * @return a representing: string the content encoded by the QR code\n   * @throws NotFoundException if a QR code cannot be found\n   * @throws FormatException if a QR code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n  //   return this.decode(image, null)\n  // }\n\n  /*@Override*/\n\n\n  QRCodeReader.prototype.decode = function (image, hints) {\n    var decoderResult;\n    var points;\n\n    if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\n      var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n      points = QRCodeReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\n      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n      points = detectorResult.getPoints();\n    } // If the code was mirrored: swap the bottom-left and the top-right points.\n\n\n    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\n      decoderResult.getOther().applyMirroredCorrection(points);\n    }\n\n    var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\n    var byteSegments = decoderResult.getByteSegments();\n\n    if (byteSegments !== null) {\n      result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n    }\n\n    var ecLevel = decoderResult.getECLevel();\n\n    if (ecLevel !== null) {\n      result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n\n    if (decoderResult.hasStructuredAppend()) {\n      result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n      result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n    }\n\n    return result;\n  };\n  /*@Override*/\n\n\n  QRCodeReader.prototype.reset = function () {// do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n   */\n\n\n  QRCodeReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n\n    if (leftTopBlack === null || rightBottomBlack === null) {\n      throw new NotFoundException_1.default();\n    }\n\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0]; // Sanity check!\n\n    if (left >= right || top >= bottom) {\n      throw new NotFoundException_1.default();\n    }\n\n    if (bottom - top !== right - left) {\n      // Special case, where bottom-right module wasn't black so we found something else in the last row\n      // Assume it's a square, so use height as the width\n      right = left + (bottom - top);\n\n      if (right >= image.getWidth()) {\n        // Abort if that would not make sense -- off image\n        throw new NotFoundException_1.default();\n      }\n    }\n\n    var matrixWidth = Math.round((right - left + 1) / moduleSize);\n    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException_1.default();\n    }\n\n    if (matrixHeight !== matrixWidth) {\n      // Only possibly decode square regions\n      throw new NotFoundException_1.default();\n    } // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n\n\n    var nudge =\n    /*(int) */\n    Math.floor(moduleSize / 2.0);\n    top += nudge;\n    left += nudge; // But careful that this does not sample off the edge\n    // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n    // This is positive by how much the inner x loop below would be too large\n\n    var nudgedTooFarRight = left +\n    /*(int) */\n    Math.floor((matrixWidth - 1) * moduleSize) - right;\n\n    if (nudgedTooFarRight > 0) {\n      if (nudgedTooFarRight > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException_1.default();\n      }\n\n      left -= nudgedTooFarRight;\n    } // See logic above\n\n\n    var nudgedTooFarDown = top +\n    /*(int) */\n    Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n\n    if (nudgedTooFarDown > 0) {\n      if (nudgedTooFarDown > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException_1.default();\n      }\n\n      top -= nudgedTooFarDown;\n    } // Now just read off the bits\n\n\n    var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top +\n      /*(int) */\n      Math.floor(y * moduleSize);\n\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left +\n        /*(int) */\n        Math.floor(x * moduleSize), iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n\n    return bits;\n  };\n\n  QRCodeReader.moduleSize = function (leftTopBlack, image) {\n    var height = image.getHeight();\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    var inBlack = true;\n    var transitions = 0;\n\n    while (x < width && y < height) {\n      if (inBlack !== image.get(x, y)) {\n        if (++transitions === 5) {\n          break;\n        }\n\n        inBlack = !inBlack;\n      }\n\n      x++;\n      y++;\n    }\n\n    if (x === width || y === height) {\n      throw new NotFoundException_1.default();\n    }\n\n    return (x - leftTopBlack[0]) / 7.0;\n  };\n\n  QRCodeReader.NO_POINTS = new Array();\n  return QRCodeReader;\n}();\n\nexports.default = QRCodeReader;","map":{"version":3,"mappings":"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","names":["Decoder_1","QRCodeReader","decoder","image","hints","decoderResult","points","undefined","get","DecodeHintType_1","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","decodeBitMatrix","NO_POINTS","detectorResult","Detector_1","detect","getBits","getPoints","getOther","QRCodeDecoderMetaData_1","applyMirroredCorrection","result","Result_1","getText","getRawBytes","BarcodeFormat_1","QR_CODE","byteSegments","getByteSegments","putMetadata","ResultMetadataType_1","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","hasStructuredAppend","STRUCTURED_APPEND_SEQUENCE","getStructuredAppendSequenceNumber","STRUCTURED_APPEND_PARITY","getStructuredAppendParity","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","NotFoundException_1","moduleSize","top","bottom","left","right","getWidth","matrixWidth","Math","round","matrixHeight","nudge","floor","nudgedTooFarRight","nudgedTooFarDown","BitMatrix_1","y","iOffset","x","set","height","getHeight","width","inBlack","transitions","Array"],"sources":["../../../src/core/qrcode/QRCodeReader.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
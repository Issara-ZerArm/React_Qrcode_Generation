{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Version_1 = require(\"./Version\");\n\nvar FormatInformation_1 = require(\"./FormatInformation\");\n\nvar DataMask_1 = require(\"./DataMask\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\n\n\nvar BitMatrixParser =\n/** @class */\nfunction () {\n  /**\n   * @param bitMatrix {@link BitMatrix} to parse\n   * @throws FormatException if dimension is not >= 21 and 1 mod 4\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n\n    if (dimension < 21 || (dimension & 0x03) !== 1) {\n      throw new FormatException_1.default();\n    }\n\n    this.bitMatrix = bitMatrix;\n  }\n  /**\n   * <p>Reads format information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link FormatInformation} encapsulating the QR Code's format info\n   * @throws FormatException if both format information locations cannot be parsed as\n   * the valid encoding of format information\n   */\n\n\n  BitMatrixParser.prototype.readFormatInformation = function () {\n    if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n      return this.parsedFormatInfo;\n    } // Read top-left format info bits\n\n\n    var formatInfoBits1 = 0;\n\n    for (var i = 0; i < 6; i++) {\n      formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n    } // .. and skip a bit in the timing pattern ...\n\n\n    formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1); // .. and skip a bit in the timing pattern ...\n\n    for (var j = 5; j >= 0; j--) {\n      formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n    } // Read the top-right/bottom-left pattern too\n\n\n    var dimension = this.bitMatrix.getHeight();\n    var formatInfoBits2 = 0;\n    var jMin = dimension - 7;\n\n    for (var j = dimension - 1; j >= jMin; j--) {\n      formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n    }\n\n    for (var i = dimension - 8; i < dimension; i++) {\n      formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n    }\n\n    this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n\n    if (this.parsedFormatInfo !== null) {\n      return this.parsedFormatInfo;\n    }\n\n    throw new FormatException_1.default();\n  };\n  /**\n   * <p>Reads version information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link Version} encapsulating the QR Code's version\n   * @throws FormatException if both version information locations cannot be parsed as\n   * the valid encoding of version information\n   */\n\n\n  BitMatrixParser.prototype.readVersion = function () {\n    if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n      return this.parsedVersion;\n    }\n\n    var dimension = this.bitMatrix.getHeight();\n    var provisionalVersion = Math.floor((dimension - 17) / 4);\n\n    if (provisionalVersion <= 6) {\n      return Version_1.default.getVersionForNumber(provisionalVersion);\n    } // Read top-right version info: 3 wide by 6 tall\n\n\n    var versionBits = 0;\n    var ijMin = dimension - 11;\n\n    for (var j = 5; j >= 0; j--) {\n      for (var i = dimension - 9; i >= ijMin; i--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n\n    var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    } // Hmm, failed. Try bottom left: 6 wide by 3 tall\n\n\n    versionBits = 0;\n\n    for (var i = 5; i >= 0; i--) {\n      for (var j = dimension - 9; j >= ijMin; j--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n\n    theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n\n    throw new FormatException_1.default();\n  };\n\n  BitMatrixParser.prototype.copyBit = function (i\n  /*int*/\n  , j\n  /*int*/\n  , versionBits\n  /*int*/\n  ) {\n    var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n    return bit ? versionBits << 1 | 0x1 : versionBits << 1;\n  };\n  /**\n   * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n   * correct order in order to reconstruct the codewords bytes contained within the\n   * QR Code.</p>\n   *\n   * @return bytes encoded within the QR Code\n   * @throws FormatException if the exact number of bytes expected is not read\n   */\n\n\n  BitMatrixParser.prototype.readCodewords = function () {\n    var formatInfo = this.readFormatInformation();\n    var version = this.readVersion(); // Get the data mask for the format used in this QR Code. This will exclude\n    // some bits from reading as we wind through the bit matrix.\n\n    var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    var functionPattern = version.buildFunctionPattern();\n    var readingUp = true;\n    var result = new Uint8Array(version.getTotalCodewords());\n    var resultOffset = 0;\n    var currentByte = 0;\n    var bitsRead = 0; // Read columns in pairs, from right to left\n\n    for (var j = dimension - 1; j > 0; j -= 2) {\n      if (j === 6) {\n        // Skip whole column with vertical alignment pattern\n        // saves time and makes the other code proceed more cleanly\n        j--;\n      } // Read alternatingly from bottom to top then top to bottom\n\n\n      for (var count = 0; count < dimension; count++) {\n        var i = readingUp ? dimension - 1 - count : count;\n\n        for (var col = 0; col < 2; col++) {\n          // Ignore bits covered by the function pattern\n          if (!functionPattern.get(j - col, i)) {\n            // Read a bit\n            bitsRead++;\n            currentByte <<= 1;\n\n            if (this.bitMatrix.get(j - col, i)) {\n              currentByte |= 1;\n            } // If we've made a whole byte, save it off\n\n\n            if (bitsRead === 8) {\n              result[resultOffset++] =\n              /*(byte) */\n              currentByte;\n              bitsRead = 0;\n              currentByte = 0;\n            }\n          }\n        }\n      }\n\n      readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n    }\n\n    if (resultOffset !== version.getTotalCodewords()) {\n      throw new FormatException_1.default();\n    }\n\n    return result;\n  };\n  /**\n   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n   */\n\n\n  BitMatrixParser.prototype.remask = function () {\n    if (this.parsedFormatInfo === null) {\n      return; // We have no format information, and have no data mask\n    }\n\n    var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n  };\n  /**\n   * Prepare the parser for a mirrored operation.\n   * This flag has effect only on the {@link #readFormatInformation()} and the\n   * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n   * {@link #mirror()} method should be called.\n   *\n   * @param mirror Whether to read version and format information mirrored.\n   */\n\n\n  BitMatrixParser.prototype.setMirror = function (isMirror) {\n    this.parsedVersion = null;\n    this.parsedFormatInfo = null;\n    this.isMirror = isMirror;\n  };\n  /** Mirror the bit matrix in order to attempt a second reading. */\n\n\n  BitMatrixParser.prototype.mirror = function () {\n    var bitMatrix = this.bitMatrix;\n\n    for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n      for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n        if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n          bitMatrix.flip(y, x);\n          bitMatrix.flip(x, y);\n        }\n      }\n    }\n  };\n\n  return BitMatrixParser;\n}();\n\nexports.default = BitMatrixParser;","map":{"version":3,"mappings":"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","names":["bitMatrix","dimension","getHeight","FormatException_1","BitMatrixParser","parsedFormatInfo","undefined","formatInfoBits1","i","copyBit","j","formatInfoBits2","jMin","FormatInformation_1","decodeFormatInformation","parsedVersion","provisionalVersion","Math","floor","Version_1","getVersionForNumber","versionBits","ijMin","theParsedVersion","decodeVersionInformation","getDimensionForVersion","bit","isMirror","get","formatInfo","readFormatInformation","version","readVersion","dataMask","DataMask_1","values","getDataMask","unmaskBitMatrix","functionPattern","buildFunctionPattern","readingUp","result","Uint8Array","getTotalCodewords","resultOffset","currentByte","bitsRead","count","col","x","width","getWidth","y","height","flip"],"sources":["../../../../src/core/qrcode/decoder/BitMatrixParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
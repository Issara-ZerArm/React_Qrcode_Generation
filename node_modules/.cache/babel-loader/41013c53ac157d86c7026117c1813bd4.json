{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * @author Satoru Takabayashi\n * @author Daniel Switkin\n * @author Sean Owen\n */\n\n\nvar MaskUtil =\n/** @class */\nfunction () {\n  function MaskUtil() {// do nothing\n  }\n  /**\n   * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n   * give penalty to them. Example: 00000 or 11111.\n   */\n\n\n  MaskUtil.applyMaskPenaltyRule1 = function (matrix) {\n    return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n  };\n  /**\n   * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n   * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n   * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n   */\n\n\n  MaskUtil.applyMaskPenaltyRule2 = function (matrix) {\n    var penalty = 0;\n    var array = matrix.getArray();\n    var width = matrix.getWidth();\n    var height = matrix.getHeight();\n\n    for (var y = 0; y < height - 1; y++) {\n      var arrayY = array[y];\n\n      for (var x = 0; x < width - 1; x++) {\n        var value = arrayY[x];\n\n        if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n          penalty++;\n        }\n      }\n    }\n\n    return MaskUtil.N2 * penalty;\n  };\n  /**\n   * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n   * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n   * find patterns like 000010111010000, we give penalty once.\n   */\n\n\n  MaskUtil.applyMaskPenaltyRule3 = function (matrix) {\n    var numPenalties = 0;\n    var array = matrix.getArray();\n    var width = matrix.getWidth();\n    var height = matrix.getHeight();\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var arrayY = array[y]; // We can at least optimize this access\n\n        if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n          numPenalties++;\n        }\n\n        if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n          numPenalties++;\n        }\n      }\n    }\n\n    return numPenalties * MaskUtil.N3;\n  };\n\n  MaskUtil.isWhiteHorizontal = function (rowArray, from\n  /*int*/\n  , to\n  /*int*/\n  ) {\n    from = Math.max(from, 0);\n    to = Math.min(to, rowArray.length);\n\n    for (var i = from; i < to; i++) {\n      if (rowArray[i] === 1) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  MaskUtil.isWhiteVertical = function (array, col\n  /*int*/\n  , from\n  /*int*/\n  , to\n  /*int*/\n  ) {\n    from = Math.max(from, 0);\n    to = Math.min(to, array.length);\n\n    for (var i = from; i < to; i++) {\n      if (array[i][col] === 1) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n   * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n   */\n\n\n  MaskUtil.applyMaskPenaltyRule4 = function (matrix) {\n    var numDarkCells = 0;\n    var array = matrix.getArray();\n    var width = matrix.getWidth();\n    var height = matrix.getHeight();\n\n    for (var y = 0; y < height; y++) {\n      var arrayY = array[y];\n\n      for (var x = 0; x < width; x++) {\n        if (arrayY[x] === 1) {\n          numDarkCells++;\n        }\n      }\n    }\n\n    var numTotalCells = matrix.getHeight() * matrix.getWidth();\n    var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n    return fivePercentVariances * MaskUtil.N4;\n  };\n  /**\n   * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n   * pattern conditions.\n   */\n\n\n  MaskUtil.getDataMaskBit = function (maskPattern\n  /*int*/\n  , x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    var intermediate;\n    /*int*/\n\n    var temp;\n    /*int*/\n\n    switch (maskPattern) {\n      case 0:\n        intermediate = y + x & 0x1;\n        break;\n\n      case 1:\n        intermediate = y & 0x1;\n        break;\n\n      case 2:\n        intermediate = x % 3;\n        break;\n\n      case 3:\n        intermediate = (y + x) % 3;\n        break;\n\n      case 4:\n        intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 0x1;\n        break;\n\n      case 5:\n        temp = y * x;\n        intermediate = (temp & 0x1) + temp % 3;\n        break;\n\n      case 6:\n        temp = y * x;\n        intermediate = (temp & 0x1) + temp % 3 & 0x1;\n        break;\n\n      case 7:\n        temp = y * x;\n        intermediate = temp % 3 + (y + x & 0x1) & 0x1;\n        break;\n\n      default:\n        throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);\n    }\n\n    return intermediate === 0;\n  };\n  /**\n   * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n   * vertical and horizontal orders respectively.\n   */\n\n\n  MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {\n    var penalty = 0;\n    var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n    var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n    var array = matrix.getArray();\n\n    for (var i = 0; i < iLimit; i++) {\n      var numSameBitCells = 0;\n      var prevBit = -1;\n\n      for (var j = 0; j < jLimit; j++) {\n        var bit = isHorizontal ? array[i][j] : array[j][i];\n\n        if (bit === prevBit) {\n          numSameBitCells++;\n        } else {\n          if (numSameBitCells >= 5) {\n            penalty += MaskUtil.N1 + (numSameBitCells - 5);\n          }\n\n          numSameBitCells = 1; // Include the cell itself.\n\n          prevBit = bit;\n        }\n      }\n\n      if (numSameBitCells >= 5) {\n        penalty += MaskUtil.N1 + (numSameBitCells - 5);\n      }\n    }\n\n    return penalty;\n  }; // Penalty weights from section 6.8.2.1\n\n\n  MaskUtil.N1 = 3;\n  MaskUtil.N2 = 3;\n  MaskUtil.N3 = 40;\n  MaskUtil.N4 = 10;\n  return MaskUtil;\n}();\n\nexports.default = MaskUtil;","map":{"version":3,"mappings":"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","names":["MaskUtil","matrix","applyMaskPenaltyRule1Internal","penalty","array","getArray","width","getWidth","height","getHeight","y","arrayY","x","value","N2","numPenalties","isWhiteHorizontal","isWhiteVertical","N3","rowArray","from","to","Math","max","min","length","i","col","numDarkCells","numTotalCells","fivePercentVariances","floor","abs","N4","maskPattern","intermediate","temp","IllegalArgumentException_1","isHorizontal","iLimit","jLimit","numSameBitCells","prevBit","j","bit","N1"],"sources":["../../../../src/core/qrcode/encoder/MaskUtil.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
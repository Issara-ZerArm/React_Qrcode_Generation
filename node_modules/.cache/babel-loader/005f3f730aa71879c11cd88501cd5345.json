{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar AlignmentPattern_1 = require(\"./AlignmentPattern\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*import java.util.ArrayList;*/\n\n/*import java.util.List;*/\n\n/**\n * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n * patterns but are smaller and appear at regular intervals throughout the image.</p>\n *\n * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n *\n * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n * pasted and stripped down here for maximum performance but does unfortunately duplicate\n * some code.</p>\n *\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n *\n * @author Sean Owen\n */\n\n\nvar AlignmentPatternFinder =\n/** @class */\nfunction () {\n  /**\n   * <p>Creates a finder that will look in a portion of the whole image.</p>\n   *\n   * @param image image to search\n   * @param startX left column from which to start searching\n   * @param startY top row from which to start searching\n   * @param width width of region to search\n   * @param height height of region to search\n   * @param moduleSize estimated module size so far\n   */\n  function AlignmentPatternFinder(image, startX\n  /*int*/\n  , startY\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  , moduleSize\n  /*float*/\n  , resultPointCallback) {\n    this.image = image;\n    this.startX = startX;\n    this.startY = startY;\n    this.width = width;\n    this.height = height;\n    this.moduleSize = moduleSize;\n    this.resultPointCallback = resultPointCallback;\n    this.possibleCenters = []; // new Array<any>(5))\n    // TYPESCRIPTPORT: array initialization without size as the length is checked below\n\n    this.crossCheckStateCount = new Int32Array(3);\n  }\n  /**\n   * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n   * it's pretty performance-critical and so is written to be fast foremost.</p>\n   *\n   * @return {@link AlignmentPattern} if found\n   * @throws NotFoundException if not found\n   */\n\n\n  AlignmentPatternFinder.prototype.find = function () {\n    var startX = this.startX;\n    var height = this.height;\n    var width = this.width;\n    var maxJ = startX + width;\n    var middleI = this.startY + height / 2; // We are looking for black/white/black modules in 1:1:1 ratio\n    // this tracks the number of black/white/black modules seen so far\n\n    var stateCount = new Int32Array(3);\n    var image = this.image;\n\n    for (var iGen = 0; iGen < height; iGen++) {\n      // Search from middle outwards\n      var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n      stateCount[0] = 0;\n      stateCount[1] = 0;\n      stateCount[2] = 0;\n      var j = startX; // Burn off leading white pixels before anything else; if we start in the middle of\n      // a white run, it doesn't make sense to count its length, since we don't know if the\n      // white run continued to the left of the start point\n\n      while (j < maxJ && !image.get(j, i)) {\n        j++;\n      }\n\n      var currentState = 0;\n\n      while (j < maxJ) {\n        if (image.get(j, i)) {\n          // Black pixel\n          if (currentState === 1) {\n            // Counting black pixels\n            stateCount[1]++;\n          } else {\n            // Counting white pixels\n            if (currentState === 2) {\n              // A winner?\n              if (this.foundPatternCross(stateCount)) {\n                // Yes\n                var confirmed = this.handlePossibleCenter(stateCount, i, j);\n\n                if (confirmed !== null) {\n                  return confirmed;\n                }\n              }\n\n              stateCount[0] = stateCount[2];\n              stateCount[1] = 1;\n              stateCount[2] = 0;\n              currentState = 1;\n            } else {\n              stateCount[++currentState]++;\n            }\n          }\n        } else {\n          // White pixel\n          if (currentState === 1) {\n            // Counting black pixels\n            currentState++;\n          }\n\n          stateCount[currentState]++;\n        }\n\n        j++;\n      }\n\n      if (this.foundPatternCross(stateCount)) {\n        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n\n        if (confirmed !== null) {\n          return confirmed;\n        }\n      }\n    } // Hmm, nothing we saw was observed and confirmed twice. If we had\n    // any guess at all, return it.\n\n\n    if (this.possibleCenters.length !== 0) {\n      return this.possibleCenters[0];\n    }\n\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Given a count of black/white/black pixels just seen and an end position,\n   * figures the location of the center of this black/white/black run.\n   */\n\n\n  AlignmentPatternFinder.centerFromEnd = function (stateCount, end\n  /*int*/\n  ) {\n    return end - stateCount[2] - stateCount[1] / 2.0;\n  };\n  /**\n   * @param stateCount count of black/white/black pixels just read\n   * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n   *         used by alignment patterns to be considered a match\n   */\n\n\n  AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {\n    var moduleSize = this.moduleSize;\n    var maxVariance = moduleSize / 2.0;\n\n    for (var i = 0; i < 3; i++) {\n      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * <p>After a horizontal scan finds a potential alignment pattern, this method\n   * \"cross-checks\" by scanning down vertically through the center of the possible\n   * alignment pattern to see if the same proportion is detected.</p>\n   *\n   * @param startI row where an alignment pattern was detected\n   * @param centerJ center of the section that appears to cross an alignment pattern\n   * @param maxCount maximum reasonable number of modules that should be\n   * observed in any reading state, based on the results of the horizontal scan\n   * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n   */\n\n\n  AlignmentPatternFinder.prototype.crossCheckVertical = function (startI\n  /*int*/\n  , centerJ\n  /*int*/\n  , maxCount\n  /*int*/\n  , originalStateCountTotal\n  /*int*/\n  ) {\n    var image = this.image;\n    var maxI = image.getHeight();\n    var stateCount = this.crossCheckStateCount;\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0; // Start counting up from center\n\n    var i = startI;\n\n    while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    } // If already too many modules in this state or ran off the edge:\n\n\n    if (i < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n\n    while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    } // Now also count down from center\n\n\n    i = startI + 1;\n\n    while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i++;\n    }\n\n    if (i === maxI || stateCount[1] > maxCount) {\n      return NaN;\n    }\n\n    while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n      stateCount[2]++;\n      i++;\n    }\n\n    if (stateCount[2] > maxCount) {\n      return NaN;\n    }\n\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n      return NaN;\n    }\n\n    return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n  };\n  /**\n   * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n   * cross check with a vertical scan, and if successful, will see if this pattern had been\n   * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n   * found the alignment pattern.</p>\n   *\n   * @param stateCount reading state module counts from horizontal scan\n   * @param i row where alignment pattern may be found\n   * @param j end of possible alignment pattern in row\n   * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n   */\n\n\n  AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i\n  /*int*/\n  , j\n  /*int*/\n  ) {\n    var e_1, _a;\n\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n    var centerI = this.crossCheckVertical(i,\n    /*(int) */\n    centerJ, 2 * stateCount[1], stateCountTotal);\n\n    if (!isNaN(centerI)) {\n      var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n\n      try {\n        for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var center = _c.value; // Look for about the same center and module size:\n\n          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n            return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Hadn't found this before; save it\n\n\n      var point = new AlignmentPattern_1.default(centerJ, centerI, estimatedModuleSize);\n      this.possibleCenters.push(point);\n\n      if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n        this.resultPointCallback.foundPossibleResultPoint(point);\n      }\n    }\n\n    return null;\n  };\n\n  return AlignmentPatternFinder;\n}();\n\nexports.default = AlignmentPatternFinder;","map":{"version":3,"mappings":"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","names":["image","startX","startY","width","height","moduleSize","resultPointCallback","possibleCenters","crossCheckStateCount","Int32Array","AlignmentPatternFinder","maxJ","middleI","stateCount","iGen","i","Math","floor","j","get","currentState","foundPatternCross","confirmed","handlePossibleCenter","length","NotFoundException_1","end","maxVariance","abs","startI","centerJ","maxCount","originalStateCountTotal","maxI","getHeight","NaN","stateCountTotal","centerFromEnd","centerI","crossCheckVertical","isNaN","estimatedModuleSize","_c","center","aboutEquals","combineEstimate","point","AlignmentPattern_1","push","undefined","foundPossibleResultPoint"],"sources":["../../../../src/core/qrcode/detector/AlignmentPatternFinder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
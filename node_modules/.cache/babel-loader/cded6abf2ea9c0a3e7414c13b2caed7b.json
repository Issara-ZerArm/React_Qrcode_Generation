{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n * number of bits read is not often a multiple of 8.</p>\n *\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n * it passed in, in which case all bets are off.</p>\n *\n * @author Sean Owen\n */\n\n\nvar BitSource =\n/** @class */\nfunction () {\n  /**\n   * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n   * Bits are read within a byte from most-significant to least-significant bit.\n   */\n  function BitSource(bytes) {\n    this.bytes = bytes;\n    this.byteOffset = 0;\n    this.bitOffset = 0;\n  }\n  /**\n   * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n   */\n\n\n  BitSource.prototype.getBitOffset = function () {\n    return this.bitOffset;\n  };\n  /**\n   * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n   */\n\n\n  BitSource.prototype.getByteOffset = function () {\n    return this.byteOffset;\n  };\n  /**\n   * @param numBits number of bits to read\n   * @return int representing the bits read. The bits will appear as the least-significant\n   *         bits of the int\n   * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n   */\n\n\n  BitSource.prototype.readBits = function (numBits\n  /*int*/\n  ) {\n    if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n      throw new IllegalArgumentException_1.default('' + numBits);\n    }\n\n    var result = 0;\n    var bitOffset = this.bitOffset;\n    var byteOffset = this.byteOffset;\n    var bytes = this.bytes; // First, read remainder from current byte\n\n    if (bitOffset > 0) {\n      var bitsLeft = 8 - bitOffset;\n      var toRead = numBits < bitsLeft ? numBits : bitsLeft;\n      var bitsToNotRead = bitsLeft - toRead;\n      var mask = 0xFF >> 8 - toRead << bitsToNotRead;\n      result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n      numBits -= toRead;\n      bitOffset += toRead;\n\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        byteOffset++;\n      }\n    } // Next read whole bytes\n\n\n    if (numBits > 0) {\n      while (numBits >= 8) {\n        result = result << 8 | bytes[byteOffset] & 0xFF;\n        byteOffset++;\n        numBits -= 8;\n      } // Finally read a partial byte\n\n\n      if (numBits > 0) {\n        var bitsToNotRead = 8 - numBits;\n        var mask = 0xFF >> bitsToNotRead << bitsToNotRead;\n        result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;\n        bitOffset += numBits;\n      }\n    }\n\n    this.bitOffset = bitOffset;\n    this.byteOffset = byteOffset;\n    return result;\n  };\n  /**\n   * @return number of bits that can be read successfully\n   */\n\n\n  BitSource.prototype.available = function () {\n    return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n  };\n\n  return BitSource;\n}();\n\nexports.default = BitSource;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAgBA;;AAGA;AAEA;;;;;;;;;;;AASA;AAAA;AAAA;AAKI;;;;AAIA,qBAA2BA,KAA3B,EAA4C;AAAjB;AACvB,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACH;AAED;;;;;AAGOC,qCAAP;AACI,WAAO,KAAKD,SAAZ;AACH,GAFM;AAIP;;;;;AAGOC,sCAAP;AACI,WAAO,KAAKF,UAAZ;AACH,GAFM;AAIP;;;;;;;;AAMOE,iCAAP,UAAgBC;AAAgB;AAAhC,IAAuC;AACnC,QAAIA,OAAO,GAAG,CAAV,IAAeA,OAAO,GAAG,EAAzB,IAA+BA,OAAO,GAAG,KAAKC,SAAL,EAA7C,EAA+D;AAC3D,YAAM,IAAIC,kCAAJ,CAA6B,KAAKF,OAAlC,CAAN;AACH;;AAED,QAAIG,MAAM,GAAG,CAAb;AAEA,QAAIL,SAAS,GAAG,KAAKA,SAArB;AACA,QAAID,UAAU,GAAG,KAAKA,UAAtB;AAEA,QAAMD,KAAK,GAAG,KAAKA,KAAnB,CAVmC,CAWnC;;AACA,QAAIE,SAAS,GAAG,CAAhB,EAAmB;AACf,UAAMM,QAAQ,GAAG,IAAIN,SAArB;AACA,UAAMO,MAAM,GAAGL,OAAO,GAAGI,QAAV,GAAqBJ,OAArB,GAA+BI,QAA9C;AACA,UAAME,aAAa,GAAGF,QAAQ,GAAGC,MAAjC;AACA,UAAME,IAAI,GAAI,QAAS,IAAIF,MAAd,IAA0BC,aAAvC;AAEAH,YAAM,GAAG,CAACP,KAAK,CAACC,UAAD,CAAL,GAAoBU,IAArB,KAA8BD,aAAvC;AACAN,aAAO,IAAIK,MAAX;AACAP,eAAS,IAAIO,MAAb;;AAEA,UAAIP,SAAS,KAAK,CAAlB,EAAqB;AACjBA,iBAAS,GAAG,CAAZ;AACAD,kBAAU;AACb;AACJ,KA1BkC,CA4BnC;;;AACA,QAAIG,OAAO,GAAG,CAAd,EAAiB;AAEb,aAAOA,OAAO,IAAI,CAAlB,EAAqB;AACjBG,cAAM,GAAIA,MAAM,IAAI,CAAX,GAAiBP,KAAK,CAACC,UAAD,CAAL,GAAoB,IAA9C;AACAA,kBAAU;AACVG,eAAO,IAAI,CAAX;AACH,OANY,CAQb;;;AACA,UAAIA,OAAO,GAAG,CAAd,EAAiB;AACb,YAAMM,aAAa,GAAG,IAAIN,OAA1B;AACA,YAAMO,IAAI,GAAI,QAAQD,aAAT,IAA2BA,aAAxC;AAEAH,cAAM,GAAIA,MAAM,IAAIH,OAAX,GAAuB,CAACJ,KAAK,CAACC,UAAD,CAAL,GAAoBU,IAArB,KAA8BD,aAA9D;AACAR,iBAAS,IAAIE,OAAb;AACH;AACJ;;AAED,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKD,UAAL,GAAkBA,UAAlB;AAEA,WAAOM,MAAP;AACH,GAnDM;AAqDP;;;;;AAGOJ,kCAAP;AACI,WAAO,KAAK,KAAKH,KAAL,CAAWY,MAAX,GAAoB,KAAKX,UAA9B,IAA4C,KAAKC,SAAxD;AACH,GAFM;;AAIX;AAAC,CA9FD","names":["bytes","byteOffset","bitOffset","BitSource","numBits","available","IllegalArgumentException_1","result","bitsLeft","toRead","bitsToNotRead","mask","length"],"sources":["../../../src/core/common/BitSource.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into\n * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n * is represented by an instance of this class.</p>\n *\n * @author Sean Owen\n */\n\n\nvar DataBlock =\n/** @class */\nfunction () {\n  function DataBlock(numDataCodewords\n  /*int*/\n  , codewords) {\n    this.numDataCodewords = numDataCodewords;\n    this.codewords = codewords;\n  }\n  /**\n   * <p>When QR Codes use multiple data blocks, they are actually interleaved.\n   * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n   * method will separate the data into original blocks.</p>\n   *\n   * @param rawCodewords bytes as read directly from the QR Code\n   * @param version version of the QR Code\n   * @param ecLevel error-correction level of the QR Code\n   * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n   *         QR Code\n   */\n\n\n  DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {\n    var e_1, _a, e_2, _b;\n\n    if (rawCodewords.length !== version.getTotalCodewords()) {\n      throw new IllegalArgumentException_1.default();\n    } // Figure out the number and size of data blocks used by this version and\n    // error correction level\n\n\n    var ecBlocks = version.getECBlocksForLevel(ecLevel); // First count the total number of data blocks\n\n    var totalBlocks = 0;\n    var ecBlockArray = ecBlocks.getECBlocks();\n\n    try {\n      for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {\n        var ecBlock = ecBlockArray_1_1.value;\n        totalBlocks += ecBlock.getCount();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Now establish DataBlocks of the appropriate size and number of data codewords\n\n\n    var result = new Array(totalBlocks);\n    var numResultBlocks = 0;\n\n    try {\n      for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {\n        var ecBlock = ecBlockArray_2_1.value;\n\n        for (var i = 0; i < ecBlock.getCount(); i++) {\n          var numDataCodewords = ecBlock.getDataCodewords();\n          var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\n          result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // All blocks have the same amount of data, except that the last n\n    // (where n may be 0) have 1 more byte. Figure out where these start.\n\n\n    var shorterBlocksTotalCodewords = result[0].codewords.length;\n    var longerBlocksStartAt = result.length - 1; // TYPESCRIPTPORT: check length is correct here\n\n    while (longerBlocksStartAt >= 0) {\n      var numCodewords = result[longerBlocksStartAt].codewords.length;\n\n      if (numCodewords === shorterBlocksTotalCodewords) {\n        break;\n      }\n\n      longerBlocksStartAt--;\n    }\n\n    longerBlocksStartAt++;\n    var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock(); // The last elements of result may be 1 element longer\n    // first fill out as many elements as all of them have\n\n    var rawCodewordsOffset = 0;\n\n    for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\n      for (var j = 0; j < numResultBlocks; j++) {\n        result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n      }\n    } // Fill out the last data block in the longer ones\n\n\n    for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {\n      result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n    } // Now add in error correction blocks\n\n\n    var max = result[0].codewords.length;\n\n    for (var i = shorterBlocksNumDataCodewords; i < max; i++) {\n      for (var j = 0; j < numResultBlocks; j++) {\n        var iOffset = j < longerBlocksStartAt ? i : i + 1;\n        result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n      }\n    }\n\n    return result;\n  };\n\n  DataBlock.prototype.getNumDataCodewords = function () {\n    return this.numDataCodewords;\n  };\n\n  DataBlock.prototype.getCodewords = function () {\n    return this.codewords;\n  };\n\n  return DataBlock;\n}();\n\nexports.default = DataBlock;","map":{"version":3,"mappings":"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","names":["numDataCodewords","codewords","DataBlock","rawCodewords","version","ecLevel","length","getTotalCodewords","IllegalArgumentException_1","ecBlocks","getECBlocksForLevel","totalBlocks","ecBlockArray","getECBlocks","ecBlockArray_1_1","ecBlock","getCount","result","Array","numResultBlocks","ecBlockArray_2_1","i","getDataCodewords","numBlockCodewords","getECCodewordsPerBlock","Uint8Array","shorterBlocksTotalCodewords","longerBlocksStartAt","numCodewords","shorterBlocksNumDataCodewords","rawCodewordsOffset","j","max","iOffset"],"sources":["../../../../src/core/qrcode/decoder/DataBlock.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
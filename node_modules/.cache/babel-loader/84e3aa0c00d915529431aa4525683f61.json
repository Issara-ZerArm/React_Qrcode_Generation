{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitArray_1 = require(\"../common/BitArray\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n\nvar ResultPoint_1 = require(\"../ResultPoint\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\n\n\nvar OneDReader =\n/** @class */\nfunction () {\n  function OneDReader() {}\n  /*\n  @Override\n  public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n    return decode(image, null);\n  }\n  */\n  // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n  // @Override\n\n\n  OneDReader.prototype.decode = function (image, hints) {\n    try {\n      return this.doDecode(image, hints);\n    } catch (nfe) {\n      var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n\n      if (tryHarder && image.isRotateSupported()) {\n        var rotatedImage = image.rotateCounterClockwise();\n        var result = this.doDecode(rotatedImage, hints); // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n\n        var metadata = result.getResultMetadata();\n        var orientation_1 = 270;\n\n        if (metadata !== null && metadata.get(ResultMetadataType_1.default.ORIENTATION) === true) {\n          // But if we found it reversed in doDecode(), add in that result here:\n          orientation_1 = orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360;\n        }\n\n        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1); // Update result points\n\n        var points = result.getResultPoints();\n\n        if (points !== null) {\n          var height = rotatedImage.getHeight();\n\n          for (var i = 0; i < points.length; i++) {\n            points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n          }\n        }\n\n        return result;\n      } else {\n        throw new NotFoundException_1.default();\n      }\n    }\n  }; // @Override\n\n\n  OneDReader.prototype.reset = function () {// do nothing\n  };\n  /**\n   * We're going to examine rows from the middle outward, searching alternately above and below the\n   * middle, and farther out each time. rowStep is the number of rows between each successive\n   * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n   * middle + rowStep, then middle - (2 * rowStep), etc.\n   * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n   * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n   * image if \"trying harder\".\n   *\n   * @param image The image to decode\n   * @param hints Any hints that were requested\n   * @return The contents of the decoded barcode\n   * @throws NotFoundException Any spontaneous errors which occur\n   */\n\n\n  OneDReader.prototype.doDecode = function (image, hints) {\n    var width = image.getWidth();\n    var height = image.getHeight();\n    var row = new BitArray_1.default(width);\n    var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n    var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n    var maxLines;\n\n    if (tryHarder) {\n      maxLines = height; // Look at the whole image, not just the center\n    } else {\n      maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n    }\n\n    var middle = Math.trunc(height / 2);\n\n    for (var x = 0; x < maxLines; x++) {\n      // Scanning from the middle out. Determine which row we're looking at next:\n      var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n      var isAbove = (x & 0x01) === 0; // i.e. is x even?\n\n      var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n\n      if (rowNumber < 0 || rowNumber >= height) {\n        // Oops, if we run off the top or bottom, stop\n        break;\n      } // Estimate black point for this row and load it:\n\n\n      try {\n        row = image.getBlackRow(rowNumber, row);\n      } catch (ignored) {\n        continue;\n      }\n\n      var _loop_1 = function _loop_1(attempt) {\n        if (attempt === 1) {\n          // trying again?\n          row.reverse(); // reverse the row and continue\n          // This means we will only ever draw result points *once* in the life of this method\n          // since we want to avoid drawing the wrong points after flipping the row, and,\n          // don't want to clutter with noise from every single row scan -- just the scans\n          // that start on the center line.\n\n          if (hints && hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true) {\n            var newHints_1 = new Map();\n            hints.forEach(function (hint, key) {\n              return newHints_1.set(key, hint);\n            });\n            newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n            hints = newHints_1;\n          }\n        }\n\n        try {\n          // Look for a barcode\n          var result = this_1.decodeRow(rowNumber, row, hints); // We found our barcode\n\n          if (attempt === 1) {\n            // But it was upside down, so note that\n            result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180); // And remember to flip the result points horizontally.\n\n            var points = result.getResultPoints();\n\n            if (points !== null) {\n              points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n              points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n            }\n          }\n\n          return {\n            value: result\n          };\n        } catch (re) {// continue -- just couldn't decode this row\n        }\n      };\n\n      var this_1 = this; // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n      // handle decoding upside down barcodes.\n\n      for (var attempt = 0; attempt < 2; attempt++) {\n        var state_1 = _loop_1(attempt);\n\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n   * The values are recorded in the given array, and the number of runs recorded is equal to the size\n   * of the array. If the row starts on a white pixel at the given start point, then the first count\n   * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n   * of black pixels if the row begin on a black pixels at that point.\n   *\n   * @param row row to count from\n   * @param start offset into row to start at\n   * @param counters array into which to record counts\n   * @throws NotFoundException if counters cannot be filled entirely from row before running out\n   *  of pixels\n   */\n\n\n  OneDReader.recordPattern = function (row, start, counters) {\n    var numCounters = counters.length;\n\n    for (var index = 0; index < numCounters; index++) {\n      counters[index] = 0;\n    }\n\n    var end = row.getSize();\n\n    if (start >= end) {\n      throw new NotFoundException_1.default();\n    }\n\n    var isWhite = !row.get(start);\n    var counterPosition = 0;\n    var i = start;\n\n    while (i < end) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (++counterPosition === numCounters) {\n          break;\n        } else {\n          counters[counterPosition] = 1;\n          isWhite = !isWhite;\n        }\n      }\n\n      i++;\n    } // If we read fully the last section of pixels and filled up our counters -- or filled\n    // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n\n\n    if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {\n      throw new NotFoundException_1.default();\n    }\n  };\n\n  OneDReader.recordPatternInReverse = function (row, start, counters) {\n    // This could be more efficient I guess\n    var numTransitionsLeft = counters.length;\n    var last = row.get(start);\n\n    while (start > 0 && numTransitionsLeft >= 0) {\n      if (row.get(--start) !== last) {\n        numTransitionsLeft--;\n        last = !last;\n      }\n    }\n\n    if (numTransitionsLeft >= 0) {\n      throw new NotFoundException_1.default();\n    }\n\n    OneDReader.recordPattern(row, start + 1, counters);\n  };\n  /**\n   * Determines how closely a set of observed counts of runs of black/white values matches a given\n   * target pattern. This is reported as the ratio of the total variance from the expected pattern\n   * proportions across all pattern elements, to the length of the pattern.\n   *\n   * @param counters observed counters\n   * @param pattern expected pattern\n   * @param maxIndividualVariance The most any counter can differ before we give up\n   * @return ratio of total variance between counters and pattern compared to total pattern size\n   */\n\n\n  OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n    var numCounters = counters.length;\n    var total = 0;\n    var patternLength = 0;\n\n    for (var i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this is too small\n      // to reliably match, so fail:\n      return Number.POSITIVE_INFINITY;\n    }\n\n    var unitBarWidth = total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n    var totalVariance = 0.0;\n\n    for (var x = 0; x < numCounters; x++) {\n      var counter = counters[x];\n      var scaledPattern = pattern[x] * unitBarWidth;\n      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n\n      if (variance > maxIndividualVariance) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      totalVariance += variance;\n    }\n\n    return totalVariance / total;\n  };\n\n  return OneDReader;\n}();\n\nexports.default = OneDReader;","map":{"version":3,"mappings":"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","names":["OneDReader","image","hints","doDecode","nfe","tryHarder","get","DecodeHintType_1","TRY_HARDER","isRotateSupported","rotatedImage","rotateCounterClockwise","result","metadata","getResultMetadata","orientation_1","ResultMetadataType_1","ORIENTATION","putMetadata","points","getResultPoints","height","getHeight","i","length","ResultPoint_1","getY","getX","NotFoundException_1","width","getWidth","row","BitArray_1","rowStep","Math","max","maxLines","middle","trunc","x","rowStepsAboveOrBelow","isAbove","rowNumber","getBlackRow","ignored","attempt","reverse","NEED_RESULT_POINT_CALLBACK","newHints_1","Map","forEach","hint","key","set","delete","this_1","decodeRow","re","start","counters","numCounters","index","end","getSize","isWhite","counterPosition","numTransitionsLeft","last","recordPattern","pattern","maxIndividualVariance","total","patternLength","Number","POSITIVE_INFINITY","unitBarWidth","totalVariance","counter","scaledPattern","variance"],"sources":["../../../src/core/oned/OneDReader.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
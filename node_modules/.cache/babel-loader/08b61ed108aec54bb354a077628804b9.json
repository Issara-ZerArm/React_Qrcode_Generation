{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\n\nvar BitMatrix_1 = require(\"./BitMatrix\");\n/**\n * This class implements a local thresholding algorithm, which while slower than the\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n * high frequency images of barcodes with black data on white backgrounds. For this application,\n * it does a much better job than a global blackpoint with severe shadows and gradients.\n * However it tends to produce artifacts on lower frequency images and is therefore not\n * a good general purpose binarizer for uses outside ZXing.\n *\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n * but for now it was not a win to use local blocks for 1D.\n *\n * This Binarizer is the default for the unit tests and the recommended class for library users.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\n\n\nvar HybridBinarizer =\n/** @class */\nfunction (_super) {\n  __extends(HybridBinarizer, _super);\n\n  function HybridBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n\n    _this.matrix = null;\n    return _this;\n  }\n  /**\n   * Calculates the final BitMatrix once for all requests. This could be called once from the\n   * constructor instead, but there are some advantages to doing it lazily, such as making\n   * profiling easier, and not doing heavy lifting when callers don't expect it.\n   */\n\n  /*@Override*/\n\n\n  HybridBinarizer.prototype.getBlackMatrix = function () {\n    if (this.matrix !== null) {\n      return this.matrix;\n    }\n\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n\n    if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n      var luminances = source.getMatrix();\n      var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subWidth++;\n      }\n\n      var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n        subHeight++;\n      }\n\n      var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n      var newMatrix = new BitMatrix_1.default(width, height);\n      HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n      this.matrix = newMatrix;\n    } else {\n      // If the image is too small, fall back to the global histogram approach.\n      this.matrix = _super.prototype.getBlackMatrix.call(this);\n    }\n\n    return this.matrix;\n  };\n  /*@Override*/\n\n\n  HybridBinarizer.prototype.createBinarizer = function (source) {\n    return new HybridBinarizer(source);\n  };\n  /**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */\n\n\n  HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth\n  /*int*/\n  , subHeight\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  , blackPoints, matrix) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n\n    for (var y = 0; y < subHeight; y++) {\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n\n      var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n\n        var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n        var sum = 0;\n\n        for (var z = -2; z <= 2; z++) {\n          var blackRow = blackPoints[top_1 + z];\n          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n        }\n\n        var average = sum / 25;\n        HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n      }\n    }\n  };\n\n  HybridBinarizer.cap = function (value\n  /*int*/\n  , min\n  /*int*/\n  , max\n  /*int*/\n  ) {\n    return value < min ? min : value > max ? max : value;\n  };\n  /**\n   * Applies a single threshold to a block of pixels.\n   */\n\n\n  HybridBinarizer.thresholdBlock = function (luminances, xoffset\n  /*int*/\n  , yoffset\n  /*int*/\n  , threshold\n  /*int*/\n  , stride\n  /*int*/\n  , matrix) {\n    for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n      for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n        if ((luminances[offset + x] & 0xFF) <= threshold) {\n          matrix.set(xoffset + x, yoffset + y);\n        }\n      }\n    }\n  };\n  /**\n   * Calculates a single black point for each block of pixels and saves it away.\n   * See the following thread for a discussion of this algorithm:\n   *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n   */\n\n\n  HybridBinarizer.calculateBlackPoints = function (luminances, subWidth\n  /*int*/\n  , subHeight\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n    var maxXOffset = width - HybridBinarizer.BLOCK_SIZE; // tslint:disable-next-line:whitespace\n\n    var blackPoints = new Array(subHeight); // subWidth\n\n    for (var y = 0; y < subHeight; y++) {\n      blackPoints[y] = new Int32Array(subWidth);\n      var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n\n      if (yoffset > maxYOffset) {\n        yoffset = maxYOffset;\n      }\n\n      for (var x = 0; x < subWidth; x++) {\n        var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n\n        if (xoffset > maxXOffset) {\n          xoffset = maxXOffset;\n        }\n\n        var sum = 0;\n        var min = 0xFF;\n        var max = 0;\n\n        for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n          for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n            var pixel = luminances[offset + xx] & 0xFF;\n            sum += pixel; // still looking for good contrast\n\n            if (pixel < min) {\n              min = pixel;\n            }\n\n            if (pixel > max) {\n              max = pixel;\n            }\n          } // short-circuit min/max tests once dynamic range is met\n\n\n          if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n            // finish the rest of the rows quickly\n            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n              for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                sum += luminances[offset + xx] & 0xFF;\n              }\n            }\n          }\n        } // The default estimate is the average of the values in the block.\n\n\n        var average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;\n\n        if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n          // If variation within the block is low, assume this is a block with only light or only\n          // dark pixels. In that case we do not want to use the average, as it would divide this\n          // low contrast area into black and white pixels, essentially creating data out of noise.\n          //\n          // The default assumption is that the block is light/background. Since no estimate for\n          // the level of dark pixels exists locally, use half the min for the block.\n          average = min / 2;\n\n          if (y > 0 && x > 0) {\n            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n            // the pixels in this block to the previously calculated black points. This is based on\n            // the fact that dark barcode symbology is always surrounded by some amount of light\n            // background for which reasonable black point estimates were made. The bp estimated at\n            // the boundaries is used for the interior.\n            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n            var averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;\n\n            if (min < averageNeighborBlackPoint) {\n              average = averageNeighborBlackPoint;\n            }\n          }\n        }\n\n        blackPoints[y][x] = average;\n      }\n    }\n\n    return blackPoints;\n  }; // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n  // So this is the smallest dimension in each axis we can accept.\n\n\n  HybridBinarizer.BLOCK_SIZE_POWER = 3;\n  HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n\n  HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n\n  HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n  HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n  return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default);\n\nexports.default = HybridBinarizer;","map":{"version":3,"mappings":"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","names":["__extends","source","_super","_this","HybridBinarizer","matrix","getLuminanceSource","width","getWidth","height","getHeight","MINIMUM_DIMENSION","luminances","getMatrix","subWidth","BLOCK_SIZE_POWER","BLOCK_SIZE_MASK","subHeight","blackPoints","calculateBlackPoints","newMatrix","BitMatrix_1","calculateThresholdForBlock","getBlackMatrix","call","maxYOffset","BLOCK_SIZE","maxXOffset","y","yoffset","top_1","cap","x","xoffset","left","sum","z","blackRow","average","thresholdBlock","value","min","max","threshold","stride","offset","set","Array","Int32Array","yy","xx","pixel","MIN_DYNAMIC_RANGE","averageNeighborBlackPoint","GlobalHistogramBinarizer_1"],"sources":["../../../src/core/common/HybridBinarizer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
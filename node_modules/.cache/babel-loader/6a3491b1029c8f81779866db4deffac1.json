{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.oned {*/\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar Result_1 = require(\"../Result\");\n\nvar ResultPoint_1 = require(\"../ResultPoint\");\n\nvar OneDReader_1 = require(\"./OneDReader\");\n\nvar StringBuilder_1 = require(\"../util/StringBuilder\");\n\nvar System_1 = require(\"../util/System\");\n\nvar FormatException_1 = require(\"../FormatException\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * <p>Decodes ITF barcodes.</p>\n *\n * @author Tjieco\n */\n\n\nvar ITFReader =\n/** @class */\nfunction (_super) {\n  __extends(ITFReader, _super);\n\n  function ITFReader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // Stores the actual narrow line width of the image being decoded.\n\n\n    _this.narrowLineWidth = -1;\n    return _this;\n  } // See ITFWriter.PATTERNS\n\n  /*\n   /!**\n   * Patterns of Wide / Narrow lines to indicate each digit\n   *!/\n  */\n\n\n  ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a; // Find out where the Middle section (payload) starts & ends\n\n\n    var startRange = this.decodeStart(row);\n    var endRange = this.decodeEnd(row);\n    var result = new StringBuilder_1.default();\n    ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n    var resultString = result.toString();\n    var allowedLengths = null;\n\n    if (hints != null) {\n      allowedLengths = hints.get(DecodeHintType_1.default.ALLOWED_LENGTHS);\n    }\n\n    if (allowedLengths == null) {\n      allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n    } // To avoid false positives with 2D barcodes (and other patterns), make\n    // an assumption that the decoded string must be a 'standard' length if it's short\n\n\n    var length = resultString.length;\n    var lengthOK = false;\n    var maxAllowedLength = 0;\n\n    try {\n      for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {\n        var value = allowedLengths_1_1.value;\n\n        if (length === value) {\n          lengthOK = true;\n          break;\n        }\n\n        if (value > maxAllowedLength) {\n          maxAllowedLength = value;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (!lengthOK && length > maxAllowedLength) {\n      lengthOK = true;\n    }\n\n    if (!lengthOK) {\n      throw new FormatException_1.default();\n    }\n\n    var points = [new ResultPoint_1.default(startRange[1], rowNumber), new ResultPoint_1.default(endRange[0], rowNumber)];\n    var resultReturn = new Result_1.default(resultString, null, // no natural byte representation for these barcodes\n    0, points, BarcodeFormat_1.default.ITF, new Date().getTime());\n    return resultReturn;\n  };\n  /*\n  /!**\n   * @param row          row of black/white values to search\n   * @param payloadStart offset of start pattern\n   * @param resultString {@link StringBuilder} to append decoded chars to\n   * @throws NotFoundException if decoding could not complete successfully\n   *!/*/\n\n\n  ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {\n    // Digits are interleaved in pairs - 5 black lines for one digit, and the\n    // 5\n    // interleaved white lines for the second digit.\n    // Therefore, need to scan 10 lines and then\n    // split these into two arrays\n    var counterDigitPair = new Array(10); // 10\n\n    var counterBlack = new Array(5); // 5\n\n    var counterWhite = new Array(5); // 5\n\n    counterDigitPair.fill(0);\n    counterBlack.fill(0);\n    counterWhite.fill(0);\n\n    while (payloadStart < payloadEnd) {\n      // Get 10 runs of black/white.\n      OneDReader_1.default.recordPattern(row, payloadStart, counterDigitPair); // Split them into each array\n\n      for (var k = 0; k < 5; k++) {\n        var twoK = 2 * k;\n        counterBlack[k] = counterDigitPair[twoK];\n        counterWhite[k] = counterDigitPair[twoK + 1];\n      }\n\n      var bestMatch = ITFReader.decodeDigit(counterBlack);\n      resultString.append(bestMatch.toString());\n      bestMatch = this.decodeDigit(counterWhite);\n      resultString.append(bestMatch.toString());\n      counterDigitPair.forEach(function (counterDigit) {\n        payloadStart += counterDigit;\n      });\n    }\n  };\n  /*/!**\n   * Identify where the start of the middle / payload section starts.\n   *\n   * @param row row of black/white values to search\n   * @return Array, containing index of start of 'start block' and end of\n   *         'start block'\n   *!/*/\n\n\n  ITFReader.prototype.decodeStart = function (row) {\n    var endStart = ITFReader.skipWhiteSpace(row);\n    var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN); // Determine the width of a narrow line in pixels. We can do this by\n    // getting the width of the start pattern and dividing by 4 because its\n    // made up of 4 narrow lines.\n\n    this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n    this.validateQuietZone(row, startPattern[0]);\n    return startPattern;\n  };\n  /*/!**\n   * The start & end patterns must be pre/post fixed by a quiet zone. This\n   * zone must be at least 10 times the width of a narrow line.  Scan back until\n   * we either get to the start of the barcode or match the necessary number of\n   * quiet zone pixels.\n   *\n   * Note: Its assumed the row is reversed when using this method to find\n   * quiet zone after the end pattern.\n   *\n   * ref: http://www.barcode-1.net/i25code.html\n   *\n   * @param row bit array representing the scanned barcode.\n   * @param startPattern index into row of the start or end pattern.\n   * @throws NotFoundException if the quiet zone cannot be found\n   *!/*/\n\n\n  ITFReader.prototype.validateQuietZone = function (row, startPattern) {\n    var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n    // if there are not so many pixel at all let's try as many as possible\n\n    quietCount = quietCount < startPattern ? quietCount : startPattern;\n\n    for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n      if (row.get(i)) {\n        break;\n      }\n\n      quietCount--;\n    }\n\n    if (quietCount !== 0) {\n      // Unable to find the necessary number of quiet zone pixels.\n      throw new NotFoundException_1.default();\n    }\n  };\n  /*\n  /!**\n   * Skip all whitespace until we get to the first black line.\n   *\n   * @param row row of black/white values to search\n   * @return index of the first black line.\n   * @throws NotFoundException Throws exception if no black lines are found in the row\n   *!/*/\n\n\n  ITFReader.skipWhiteSpace = function (row) {\n    var width = row.getSize();\n    var endStart = row.getNextSet(0);\n\n    if (endStart === width) {\n      throw new NotFoundException_1.default();\n    }\n\n    return endStart;\n  };\n  /*/!**\n   * Identify where the end of the middle / payload section ends.\n   *\n   * @param row row of black/white values to search\n   * @return Array, containing index of start of 'end block' and end of 'end\n   *         block'\n   *!/*/\n\n\n  ITFReader.prototype.decodeEnd = function (row) {\n    // For convenience, reverse the row and then\n    // search from 'the start' for the end block\n    row.reverse();\n\n    try {\n      var endStart = ITFReader.skipWhiteSpace(row);\n      var endPattern = void 0;\n\n      try {\n        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n      } catch (NotFoundException) {\n        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n      } // The start & end patterns must be pre/post fixed by a quiet zone. This\n      // zone must be at least 10 times the width of a narrow line.\n      // ref: http://www.barcode-1.net/i25code.html\n\n\n      this.validateQuietZone(row, endPattern[0]); // Now recalculate the indices of where the 'endblock' starts & stops to\n      // accommodate\n      // the reversed nature of the search\n\n      var temp = endPattern[0];\n      endPattern[0] = row.getSize() - endPattern[1];\n      endPattern[1] = row.getSize() - temp;\n      return endPattern;\n    } finally {\n      // Put the row back the right way.\n      row.reverse();\n    }\n  };\n  /*\n  /!**\n   * @param row       row of black/white values to search\n   * @param rowOffset position to start search\n   * @param pattern   pattern of counts of number of black and white pixels that are\n   *                  being searched for as a pattern\n   * @return start/end horizontal offset of guard pattern, as an array of two\n   *         ints\n   * @throws NotFoundException if pattern is not found\n   *!/*/\n\n\n  ITFReader.findGuardPattern = function (row, rowOffset, pattern) {\n    var patternLength = pattern.length;\n    var counters = new Array(patternLength);\n    var width = row.getSize();\n    var isWhite = false;\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    counters.fill(0);\n\n    for (var x = rowOffset; x < width; x++) {\n      if (row.get(x) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n            return [patternStart, x];\n          }\n\n          patternStart += counters[0] + counters[1];\n          System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  };\n  /*/!**\n   * Attempts to decode a sequence of ITF black/white lines into single\n   * digit.\n   *\n   * @param counters the counts of runs of observed black/white/black/... values\n   * @return The decoded digit\n   * @throws NotFoundException if digit cannot be decoded\n   *!/*/\n\n\n  ITFReader.decodeDigit = function (counters) {\n    var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n\n    var bestMatch = -1;\n    var max = ITFReader.PATTERNS.length;\n\n    for (var i = 0; i < max; i++) {\n      var pattern = ITFReader.PATTERNS[i];\n      var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = i;\n      } else if (variance === bestVariance) {\n        // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n        bestMatch = -1;\n      }\n    }\n\n    if (bestMatch >= 0) {\n      return bestMatch % 10;\n    } else {\n      throw new NotFoundException_1.default();\n    }\n  };\n\n  ITFReader.W = 3; // Pixel width of a 3x wide line\n\n  ITFReader.w = 2; // Pixel width of a 2x wide line\n\n  ITFReader.N = 1; // Pixed width of a narrow line\n\n  ITFReader.PATTERNS = [[1, 1, 2, 2, 1], [2, 1, 1, 1, 2], [1, 2, 1, 1, 2], [2, 2, 1, 1, 1], [1, 1, 2, 1, 2], [2, 1, 2, 1, 1], [1, 2, 2, 1, 1], [1, 1, 1, 2, 2], [2, 1, 1, 2, 1], [1, 2, 1, 2, 1], [1, 1, 3, 3, 1], [3, 1, 1, 1, 3], [1, 3, 1, 1, 3], [3, 3, 1, 1, 1], [1, 1, 3, 1, 3], [3, 1, 3, 1, 1], [1, 3, 3, 1, 1], [1, 1, 1, 3, 3], [3, 1, 1, 3, 1], [1, 3, 1, 3, 1] // 9\n  ];\n  ITFReader.MAX_AVG_VARIANCE = 0.38;\n  ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n  /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n\n  ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n  /*/!**\n   * Start/end guard pattern.\n   *\n   * Note: The end pattern is reversed because the row is reversed before\n   * searching for the END_PATTERN\n   *!/*/\n\n  ITFReader.START_PATTERN = [1, 1, 1, 1];\n  ITFReader.END_PATTERN_REVERSED = [[1, 1, 2], [1, 1, 3] // 3x\n  ];\n  return ITFReader;\n}(OneDReader_1.default);\n\nexports.default = ITFReader;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;AAEA;;AAEA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;AAEA;;;;;;;AAKA;AAAA;AAAA;AAAuCA;;AAAvC;AAAA,0EAqCI;;;AACQC,4BAAkB,CAAC,CAAnB;;AA0UX,GAhXD,CAoDI;;AACA;;;;;;;AAOOC,kCAAP,UAAiBC,SAAjB,EAAoCC,GAApC,EAAmDC,KAAnD,EAAmF;gBAAA,CAE/E;;;AACA,QAAIC,UAAU,GAAa,KAAKC,WAAL,CAAiBH,GAAjB,CAA3B;AACA,QAAII,QAAQ,GAAa,KAAKC,SAAL,CAAeL,GAAf,CAAzB;AAEA,QAAIM,MAAM,GAAkB,IAAIC,uBAAJ,EAA5B;AACAT,aAAS,CAACU,YAAV,CAAuBR,GAAvB,EAA4BE,UAAU,CAAC,CAAD,CAAtC,EAA2CE,QAAQ,CAAC,CAAD,CAAnD,EAAwDE,MAAxD;AACA,QAAIG,YAAY,GAAWH,MAAM,CAACI,QAAP,EAA3B;AAEA,QAAIC,cAAc,GAAa,IAA/B;;AACA,QAAIV,KAAK,IAAI,IAAb,EAAmB;AACfU,oBAAc,GAAGV,KAAK,CAACW,GAAN,CAAUC,yBAAeC,eAAzB,CAAjB;AAEH;;AACD,QAAIH,cAAc,IAAI,IAAtB,EAA4B;AACxBA,oBAAc,GAAGb,SAAS,CAACiB,uBAA3B;AACH,KAjB8E,CAmB/E;AACA;;;AACA,QAAIC,MAAM,GAAWP,YAAY,CAACO,MAAlC;AACA,QAAIC,QAAQ,GAAY,KAAxB;AACA,QAAIC,gBAAgB,GAAW,CAA/B;;;AAEA,WAAkB,iDAAcC,4CAAhC,EAAgC,wBAAhC,EAAgCA,4CAAhC,EAAkC;AAA7B,YAAIC,KAAK,2BAAT;;AACD,YAAIJ,MAAM,KAAKI,KAAf,EAAsB;AAClBH,kBAAQ,GAAG,IAAX;AACA;AACH;;AACD,YAAIG,KAAK,GAAGF,gBAAZ,EAA8B;AAC1BA,0BAAgB,GAAGE,KAAnB;AACH;AACJ;;;;;;;;;;;;;AAED,QAAI,CAACH,QAAD,IAAaD,MAAM,GAAGE,gBAA1B,EAA4C;AACxCD,cAAQ,GAAG,IAAX;AACH;;AAED,QAAI,CAACA,QAAL,EAAe;AACX,YAAM,IAAII,yBAAJ,EAAN;AACH;;AAED,QAAMC,MAAM,GAAkB,CAAC,IAAIC,qBAAJ,CAAgBrB,UAAU,CAAC,CAAD,CAA1B,EAA+BH,SAA/B,CAAD,EAA4C,IAAIwB,qBAAJ,CAAgBnB,QAAQ,CAAC,CAAD,CAAxB,EAA6BL,SAA7B,CAA5C,CAA9B;AAEA,QAAIyB,YAAY,GAAW,IAAIC,gBAAJ,CACvBhB,YADuB,EAEvB,IAFuB,EAEjB;AACN,KAHuB,EAIvBa,MAJuB,EAKvBI,wBAAcC,GALS,EAMvB,IAAIC,IAAJ,GAAWC,OAAX,EANuB,CAA3B;AASA,WAAOL,YAAP;AACH,GAvDM;AAwDP;;;;;;;;;AAOe1B,2BAAf,UACIE,GADJ,EAEI8B,YAFJ,EAGIC,UAHJ,EAIItB,YAJJ,EAI+B;AAG3B;AACA;AACA;AACA;AACA;AAEA,QAAIuB,gBAAgB,GAAa,IAAIC,KAAJ,CAAU,EAAV,CAAjC,CAT2B,CASqB;;AAChD,QAAIC,YAAY,GAAa,IAAID,KAAJ,CAAU,CAAV,CAA7B,CAV2B,CAUgB;;AAC3C,QAAIE,YAAY,GAAa,IAAIF,KAAJ,CAAU,CAAV,CAA7B,CAX2B,CAWgB;;AAE3CD,oBAAgB,CAACI,IAAjB,CAAsB,CAAtB;AACAF,gBAAY,CAACE,IAAb,CAAkB,CAAlB;AACAD,gBAAY,CAACC,IAAb,CAAkB,CAAlB;;AAEA,WAAON,YAAY,GAAGC,UAAtB,EAAkC;AAE9B;AACAM,2BAAWC,aAAX,CAAyBtC,GAAzB,EAA8B8B,YAA9B,EAA4CE,gBAA5C,EAH8B,CAI9B;;AACA,WAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AACxB,YAAIC,IAAI,GAAW,IAAID,CAAvB;AACAL,oBAAY,CAACK,CAAD,CAAZ,GAAkBP,gBAAgB,CAACQ,IAAD,CAAlC;AACAL,oBAAY,CAACI,CAAD,CAAZ,GAAkBP,gBAAgB,CAACQ,IAAI,GAAG,CAAR,CAAlC;AACH;;AAED,UAAIC,SAAS,GAAW3C,SAAS,CAAC4C,WAAV,CAAsBR,YAAtB,CAAxB;AACAzB,kBAAY,CAACkC,MAAb,CAAoBF,SAAS,CAAC/B,QAAV,EAApB;AACA+B,eAAS,GAAG,KAAKC,WAAL,CAAiBP,YAAjB,CAAZ;AACA1B,kBAAY,CAACkC,MAAb,CAAoBF,SAAS,CAAC/B,QAAV,EAApB;AAEAsB,sBAAgB,CAACY,OAAjB,CAAyB,UAASC,YAAT,EAAqB;AAC1Cf,oBAAY,IAAIe,YAAhB;AACH,OAFD;AAGH;AACJ,GAzCc;AA2Cf;;;;;;;;;AAOQ/C,oCAAR,UAAoBE,GAApB,EAAiC;AAE7B,QAAI8C,QAAQ,GAAGhD,SAAS,CAACiD,cAAV,CAAyB/C,GAAzB,CAAf;AACA,QAAIgD,YAAY,GAAalD,SAAS,CAACmD,gBAAV,CAA2BjD,GAA3B,EAAgC8C,QAAhC,EAA0ChD,SAAS,CAACoD,aAApD,CAA7B,CAH6B,CAK7B;AACA;AACA;;AACA,SAAKC,eAAL,GAAuB,CAACH,YAAY,CAAC,CAAD,CAAZ,GAAkBA,YAAY,CAAC,CAAD,CAA/B,IAAsC,CAA7D;AAEA,SAAKI,iBAAL,CAAuBpD,GAAvB,EAA4BgD,YAAY,CAAC,CAAD,CAAxC;AAEA,WAAOA,YAAP;AACH,GAbO;AAeR;;;;;;;;;;;;;;;;;AAeQlD,0CAAR,UAA0BE,GAA1B,EAAyCgD,YAAzC,EAA6D;AAEzD,QAAIK,UAAU,GAAW,KAAKF,eAAL,GAAuB,EAAhD,CAFyD,CAEJ;AAErD;;AACAE,cAAU,GAAGA,UAAU,GAAGL,YAAb,GAA4BK,UAA5B,GAAyCL,YAAtD;;AAEA,SAAK,IAAIM,CAAC,GAAGN,YAAY,GAAG,CAA5B,EAA+BK,UAAU,GAAG,CAAb,IAAkBC,CAAC,IAAI,CAAtD,EAAyDA,CAAC,EAA1D,EAA8D;AAC1D,UAAItD,GAAG,CAACY,GAAJ,CAAQ0C,CAAR,CAAJ,EAAgB;AACZ;AACH;;AACDD,gBAAU;AACb;;AACD,QAAIA,UAAU,KAAK,CAAnB,EAAsB;AAClB;AACA,YAAM,IAAIE,2BAAJ,EAAN;AACH;AACJ,GAjBO;AAkBR;;;;;;;;;;AAQezD,6BAAf,UAA8BE,GAA9B,EAA2C;AAEvC,QAAMwD,KAAK,GAAGxD,GAAG,CAACyD,OAAJ,EAAd;AACA,QAAMX,QAAQ,GAAG9C,GAAG,CAAC0D,UAAJ,CAAe,CAAf,CAAjB;;AAEA,QAAIZ,QAAQ,KAAKU,KAAjB,EAAwB;AACpB,YAAM,IAAID,2BAAJ,EAAN;AACH;;AAED,WAAOT,QAAP;AACH,GAVc;AAYf;;;;;;;;;AAOQhD,kCAAR,UAAkBE,GAAlB,EAA+B;AAE3B;AACA;AACAA,OAAG,CAAC2D,OAAJ;;AAEA,QAAI;AACA,UAAIb,QAAQ,GAAWhD,SAAS,CAACiD,cAAV,CAAyB/C,GAAzB,CAAvB;AACA,UAAI4D,UAAU,SAAd;;AAEA,UAAI;AACAA,kBAAU,GAAG9D,SAAS,CAACmD,gBAAV,CAA2BjD,GAA3B,EAAgC8C,QAAhC,EAA0ChD,SAAS,CAAC+D,oBAAV,CAA+B,CAA/B,CAA1C,CAAb;AACH,OAFD,CAEE,OAAOC,iBAAP,EAA0B;AACxBF,kBAAU,GAAG9D,SAAS,CAACmD,gBAAV,CAA2BjD,GAA3B,EAAgC8C,QAAhC,EAA0ChD,SAAS,CAAC+D,oBAAV,CAA+B,CAA/B,CAA1C,CAAb;AACH,OARD,CAUA;AACA;AACA;;;AACA,WAAKT,iBAAL,CAAuBpD,GAAvB,EAA4B4D,UAAU,CAAC,CAAD,CAAtC,EAbA,CAeA;AACA;AACA;;AACA,UAAIG,IAAI,GAAGH,UAAU,CAAC,CAAD,CAArB;AACAA,gBAAU,CAAC,CAAD,CAAV,GAAgB5D,GAAG,CAACyD,OAAJ,KAAgBG,UAAU,CAAC,CAAD,CAA1C;AACAA,gBAAU,CAAC,CAAD,CAAV,GAAgB5D,GAAG,CAACyD,OAAJ,KAAgBM,IAAhC;AAEA,aAAOH,UAAP;AAEH,KAxBD,SAwBU;AACN;AACA5D,SAAG,CAAC2D,OAAJ;AACH;AACJ,GAlCO;AAoCR;;;;;;;;;;;;AAUe7D,+BAAf,UACIE,GADJ,EAEIgE,SAFJ,EAGIC,OAHJ,EAGqB;AAGjB,QAAIC,aAAa,GAAWD,OAAO,CAACjD,MAApC;AACA,QAAImD,QAAQ,GAAa,IAAIlC,KAAJ,CAAUiC,aAAV,CAAzB;AACA,QAAIV,KAAK,GAAWxD,GAAG,CAACyD,OAAJ,EAApB;AACA,QAAIW,OAAO,GAAY,KAAvB;AAEA,QAAIC,eAAe,GAAW,CAA9B;AACA,QAAIC,YAAY,GAAWN,SAA3B;AAEAG,YAAQ,CAAC/B,IAAT,CAAc,CAAd;;AAEA,SAAK,IAAImC,CAAC,GAAGP,SAAb,EAAwBO,CAAC,GAAGf,KAA5B,EAAmCe,CAAC,EAApC,EAAwC;AACpC,UAAIvE,GAAG,CAACY,GAAJ,CAAQ2D,CAAR,MAAeH,OAAnB,EAA4B;AACxBD,gBAAQ,CAACE,eAAD,CAAR;AACH,OAFD,MAEO;AACH,YAAIA,eAAe,KAAKH,aAAa,GAAG,CAAxC,EAA2C;AACvC,cAAI7B,qBAAWmC,oBAAX,CAAgCL,QAAhC,EAA0CF,OAA1C,EAAmDnE,SAAS,CAAC2E,uBAA7D,IAAwF3E,SAAS,CAAC4E,gBAAtG,EAAwH;AACpH,mBAAO,CAACJ,YAAD,EAAeC,CAAf,CAAP;AACH;;AACDD,sBAAY,IAAIH,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtC;AACAQ,2BAAOC,SAAP,CAAiBT,QAAjB,EAA2B,CAA3B,EAA8BA,QAA9B,EAAwC,CAAxC,EAA2CE,eAAe,GAAG,CAA7D;AACAF,kBAAQ,CAACE,eAAe,GAAG,CAAnB,CAAR,GAAgC,CAAhC;AACAF,kBAAQ,CAACE,eAAD,CAAR,GAA4B,CAA5B;AACAA,yBAAe;AAClB,SATD,MASO;AACHA,yBAAe;AAClB;;AACDF,gBAAQ,CAACE,eAAD,CAAR,GAA4B,CAA5B;AACAD,eAAO,GAAG,CAACA,OAAX;AACH;AACJ;;AACD,UAAM,IAAIb,2BAAJ,EAAN;AACH,GArCc;AAuCf;;;;;;;;;;AAQezD,0BAAf,UAA2BqE,QAA3B,EAA6C;AAEzC,QAAIU,YAAY,GAAW/E,SAAS,CAAC4E,gBAArC,CAFyC,CAEc;;AACvD,QAAIjC,SAAS,GAAW,CAAC,CAAzB;AACA,QAAIqC,GAAG,GAAWhF,SAAS,CAACiF,QAAV,CAAmB/D,MAArC;;AAEA,SAAK,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,GAApB,EAAyBxB,CAAC,EAA1B,EAA8B;AAE1B,UAAIW,OAAO,GAAGnE,SAAS,CAACiF,QAAV,CAAmBzB,CAAnB,CAAd;AACA,UAAI0B,QAAQ,GAAW3C,qBAAWmC,oBAAX,CAAgCL,QAAhC,EAA0CF,OAA1C,EAAmDnE,SAAS,CAAC2E,uBAA7D,CAAvB;;AAEA,UAAIO,QAAQ,GAAGH,YAAf,EAA6B;AACzBA,oBAAY,GAAGG,QAAf;AACAvC,iBAAS,GAAGa,CAAZ;AACH,OAHD,MAGO,IAAI0B,QAAQ,KAAKH,YAAjB,EAA+B;AAClC;AACApC,iBAAS,GAAG,CAAC,CAAb;AACH;AACJ;;AAED,QAAIA,SAAS,IAAI,CAAjB,EAAoB;AAChB,aAAOA,SAAS,GAAG,EAAnB;AACH,KAFD,MAEO;AACH,YAAM,IAAIc,2BAAJ,EAAN;AACH;AACJ,GAzBc;;AAnVAzD,gBAAI,CAAJ,CAFnB,CAE0B;;AACPA,gBAAI,CAAJ,CAHnB,CAG0B;;AACPA,gBAAI,CAAJ,CAJnB,CAI0B;;AAEPA,uBAAuB,CAClC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CADkC,EAElC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAFkC,EAGlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAHkC,EAIlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAJkC,EAKlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CALkC,EAMlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CANkC,EAOlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAPkC,EAQlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CARkC,EASlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CATkC,EAUlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAVkC,EAWlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAXkC,EAYlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAZkC,EAalC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAbkC,EAclC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAdkC,EAelC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAfkC,EAgBlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAhBkC,EAiBlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAjBkC,EAkBlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAlBkC,EAmBlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAnBkC,EAoBlC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CApBkC,CAoBjB;AApBiB,GAAvB;AAuBCA,+BAAmB,IAAnB;AACAA,sCAA0B,GAA1B;AAIhB;;AACeA,sCAAoC,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP,EAAW,EAAX,EAAe,EAAf,CAApC;AAKf;;;;;;;AAMeA,4BAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAhB;AACAA,mCAAmC,CAC9C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAD8C,EAE9C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAF8C,CAEnC;AAFmC,GAAnC;AAiUnB;AAAC,CAhXD,CAAuCuC,oBAAvC;;kBAAqBvC","names":["__extends","_this","ITFReader","rowNumber","row","hints","startRange","decodeStart","endRange","decodeEnd","result","StringBuilder_1","decodeMiddle","resultString","toString","allowedLengths","get","DecodeHintType_1","ALLOWED_LENGTHS","DEFAULT_ALLOWED_LENGTHS","length","lengthOK","maxAllowedLength","allowedLengths_1_1","value","FormatException_1","points","ResultPoint_1","resultReturn","Result_1","BarcodeFormat_1","ITF","Date","getTime","payloadStart","payloadEnd","counterDigitPair","Array","counterBlack","counterWhite","fill","OneDReader_1","recordPattern","k","twoK","bestMatch","decodeDigit","append","forEach","counterDigit","endStart","skipWhiteSpace","startPattern","findGuardPattern","START_PATTERN","narrowLineWidth","validateQuietZone","quietCount","i","NotFoundException_1","width","getSize","getNextSet","reverse","endPattern","END_PATTERN_REVERSED","NotFoundException","temp","rowOffset","pattern","patternLength","counters","isWhite","counterPosition","patternStart","x","patternMatchVariance","MAX_INDIVIDUAL_VARIANCE","MAX_AVG_VARIANCE","System_1","arraycopy","bestVariance","max","PATTERNS","variance"],"sources":["../../../src/core/oned/ITFReader.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
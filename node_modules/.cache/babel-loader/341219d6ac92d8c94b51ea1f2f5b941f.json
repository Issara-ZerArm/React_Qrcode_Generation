{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitSource_1 = require(\"../../common/BitSource\");\n\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\n\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\n\nvar StringUtils_1 = require(\"../../common/StringUtils\");\n\nvar Mode_1 = require(\"./Mode\");\n\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\n\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n/*import java.io.UnsupportedEncodingException;*/\n\n/*import java.util.ArrayList;*/\n\n/*import java.util.Collection;*/\n\n/*import java.util.List;*/\n\n/*import java.util.Map;*/\n\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\n\n\nvar DecodedBitStreamParser =\n/** @class */\nfunction () {\n  function DecodedBitStreamParser() {}\n\n  DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n    var bits = new BitSource_1.default(bytes);\n    var result = new StringBuilder_1.default();\n    var byteSegments = new Array(); // 1\n    // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n\n    var symbolSequence = -1;\n    var parityData = -1;\n\n    try {\n      var currentCharacterSetECI = null;\n      var fc1InEffect = false;\n      var mode = void 0;\n\n      do {\n        // While still another segment to read...\n        if (bits.available() < 4) {\n          // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n          mode = Mode_1.default.TERMINATOR;\n        } else {\n          var modeBits = bits.readBits(4);\n          mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n        }\n\n        switch (mode) {\n          case Mode_1.default.TERMINATOR:\n            break;\n\n          case Mode_1.default.FNC1_FIRST_POSITION:\n          case Mode_1.default.FNC1_SECOND_POSITION:\n            // We do little with FNC1 except alter the parsed result a bit according to the spec\n            fc1InEffect = true;\n            break;\n\n          case Mode_1.default.STRUCTURED_APPEND:\n            if (bits.available() < 16) {\n              throw new FormatException_1.default();\n            } // sequence number and parity is added later to the result metadata\n            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n\n\n            symbolSequence = bits.readBits(8);\n            parityData = bits.readBits(8);\n            break;\n\n          case Mode_1.default.ECI:\n            // Count doesn't apply to ECI\n            var value = DecodedBitStreamParser.parseECIValue(bits);\n            currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n\n            if (currentCharacterSetECI === null) {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case Mode_1.default.HANZI:\n            // First handle Hanzi mode which does not start with character count\n            // Chinese mode contains a sub set indicator right after mode indicator\n            var subset = bits.readBits(4);\n            var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n\n            if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n              DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n            }\n\n            break;\n\n          default:\n            // \"Normal\" QR code modes:\n            // How many characters will follow, encoded in this mode?\n            var count = bits.readBits(mode.getCharacterCountBits(version));\n\n            switch (mode) {\n              case Mode_1.default.NUMERIC:\n                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                break;\n\n              case Mode_1.default.ALPHANUMERIC:\n                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                break;\n\n              case Mode_1.default.BYTE:\n                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                break;\n\n              case Mode_1.default.KANJI:\n                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                break;\n\n              default:\n                throw new FormatException_1.default();\n            }\n\n            break;\n        }\n      } while (mode !== Mode_1.default.TERMINATOR);\n    } catch (iae\n    /*: IllegalArgumentException*/\n    ) {\n      // from readBits() calls\n      throw new FormatException_1.default();\n    }\n\n    return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n  };\n  /**\n   * See specification GBT 18284-2000\n   */\n\n\n  DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x060 << 8 & 0xFFFFFFFF | twoBytes % 0x060;\n\n      if (assembledTwoBytes < 0x003BF) {\n        // In the 0xA1A1 to 0xAAFE range\n        assembledTwoBytes += 0x0A1A1;\n      } else {\n        // In the 0xB0A1 to 0xFAFE range\n        assembledTwoBytes += 0x0A6A1;\n      }\n\n      buffer[offset] =\n      /*(byte) */\n      assembledTwoBytes >> 8 & 0xFF;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes & 0xFF;\n      offset += 2;\n      count--;\n    }\n\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312)); // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n      throw new FormatException_1.default();\n    } // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as Shift_JIS afterwards\n\n\n    var buffer = new Uint8Array(2 * count);\n    var offset = 0;\n\n    while (count > 0) {\n      // Each 13 bits encodes a 2-byte character\n      var twoBytes = bits.readBits(13);\n      var assembledTwoBytes = twoBytes / 0x0C0 << 8 & 0xFFFFFFFF | twoBytes % 0x0C0;\n\n      if (assembledTwoBytes < 0x01F00) {\n        // In the 0x8140 to 0x9FFC range\n        assembledTwoBytes += 0x08140;\n      } else {\n        // In the 0xE040 to 0xEBBF range\n        assembledTwoBytes += 0x0C140;\n      }\n\n      buffer[offset] =\n      /*(byte) */\n      assembledTwoBytes >> 8;\n      buffer[offset + 1] =\n      /*(byte) */\n      assembledTwoBytes;\n      offset += 2;\n      count--;\n    } // Shift_JIS may not be supported in some environments:\n\n\n    try {\n      result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS)); // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n  };\n\n  DecodedBitStreamParser.decodeByteSegment = function (bits, result, count\n  /*int*/\n  , currentCharacterSetECI, byteSegments, hints) {\n    // Don't crash trying to read more bits than we have available.\n    if (8 * count > bits.available()) {\n      throw new FormatException_1.default();\n    }\n\n    var readBytes = new Uint8Array(count);\n\n    for (var i = 0; i < count; i++) {\n      readBytes[i] =\n      /*(byte) */\n      bits.readBits(8);\n    }\n\n    var encoding;\n\n    if (currentCharacterSetECI === null) {\n      // The spec isn't clear on this mode; see\n      // section 6.4.5: t does not say which encoding to assuming\n      // upon decoding. I have seen ISO-8859-1 used as well as\n      // Shift_JIS -- without anything like an ECI designator to\n      // give a hint.\n      encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n    } else {\n      encoding = currentCharacterSetECI.getName();\n    }\n\n    try {\n      result.append(StringEncoding_1.default.decode(readBytes, encoding));\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new FormatException_1.default(ignored);\n    }\n\n    byteSegments.push(readBytes);\n  };\n\n  DecodedBitStreamParser.toAlphaNumericChar = function (value\n  /*int*/\n  ) {\n    if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n      throw new FormatException_1.default();\n    }\n\n    return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n  };\n\n  DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count\n  /*int*/\n  , fc1InEffect) {\n    // Read two characters at a time\n    var start = result.length();\n\n    while (count > 1) {\n      if (bits.available() < 11) {\n        throw new FormatException_1.default();\n      }\n\n      var nextTwoCharsBits = bits.readBits(11);\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n      count -= 2;\n    }\n\n    if (count === 1) {\n      // special case: one character left\n      if (bits.available() < 6) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n    } // See section 6.4.8.1, 6.4.8.2\n\n\n    if (fc1InEffect) {\n      // We need to massage the result a bit if in an FNC1 mode:\n      for (var i = start; i < result.length(); i++) {\n        if (result.charAt(i) === '%') {\n          if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n            // %% is rendered as %\n            result.deleteCharAt(i + 1);\n          } else {\n            // In alpha mode, % should be converted to FNC1 separator 0x1D\n            result.setCharAt(i, String.fromCharCode(0x1D));\n          }\n        }\n      }\n    }\n  };\n\n  DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count\n  /*int*/\n  ) {\n    // Read three digits at a time\n    while (count >= 3) {\n      // Each 10 bits encodes three digits\n      if (bits.available() < 10) {\n        throw new FormatException_1.default();\n      }\n\n      var threeDigitsBits = bits.readBits(10);\n\n      if (threeDigitsBits >= 1000) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n      count -= 3;\n    }\n\n    if (count === 2) {\n      // Two digits left over to read, encoded in 7 bits\n      if (bits.available() < 7) {\n        throw new FormatException_1.default();\n      }\n\n      var twoDigitsBits = bits.readBits(7);\n\n      if (twoDigitsBits >= 100) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n    } else if (count === 1) {\n      // One digit left over to read\n      if (bits.available() < 4) {\n        throw new FormatException_1.default();\n      }\n\n      var digitBits = bits.readBits(4);\n\n      if (digitBits >= 10) {\n        throw new FormatException_1.default();\n      }\n\n      result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n    }\n  };\n\n  DecodedBitStreamParser.parseECIValue = function (bits) {\n    var firstByte = bits.readBits(8);\n\n    if ((firstByte & 0x80) === 0) {\n      // just one byte\n      return firstByte & 0x7F;\n    }\n\n    if ((firstByte & 0xC0) === 0x80) {\n      // two bytes\n      var secondByte = bits.readBits(8);\n      return (firstByte & 0x3F) << 8 & 0xFFFFFFFF | secondByte;\n    }\n\n    if ((firstByte & 0xE0) === 0xC0) {\n      // three bytes\n      var secondThirdBytes = bits.readBits(16);\n      return (firstByte & 0x1F) << 16 & 0xFFFFFFFF | secondThirdBytes;\n    }\n\n    throw new FormatException_1.default();\n  };\n  /**\n   * See ISO 18004:2006, 6.4.4 Table 5\n   */\n\n\n  DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n  DecodedBitStreamParser.GB2312_SUBSET = 1;\n  return DecodedBitStreamParser;\n}();\n\nexports.default = DecodedBitStreamParser;\n\nfunction Uint8ArrayToString(a) {\n  var CHUNK_SZ = 0x8000;\n  var c = new StringBuilder_1.default();\n\n  for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {\n    c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n  }\n\n  return c.toString();\n}","map":{"version":3,"mappings":"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","names":["DecodedBitStreamParser","bytes","version","ecLevel","hints","bits","BitSource_1","result","StringBuilder_1","byteSegments","Array","symbolSequence","parityData","currentCharacterSetECI","fc1InEffect","mode","available","Mode_1","TERMINATOR","modeBits","readBits","forBits","FNC1_FIRST_POSITION","FNC1_SECOND_POSITION","STRUCTURED_APPEND","FormatException_1","ECI","value","parseECIValue","CharacterSetECI_1","getCharacterSetECIByValue","HANZI","subset","countHanzi","getCharacterCountBits","GB2312_SUBSET","decodeHanziSegment","count","NUMERIC","decodeNumericSegment","ALPHANUMERIC","decodeAlphanumericSegment","BYTE","decodeByteSegment","KANJI","decodeKanjiSegment","iae","DecoderResult_1","toString","length","buffer","Uint8Array","offset","twoBytes","assembledTwoBytes","append","StringEncoding_1","decode","StringUtils_1","GB2312","ignored","SHIFT_JIS","readBytes","i","encoding","guessEncoding","getName","push","ALPHANUMERIC_CHARS","start","nextTwoCharsBits","toAlphaNumericChar","Math","floor","charAt","deleteCharAt","setCharAt","String","fromCharCode","threeDigitsBits","twoDigitsBits","digitBits","firstByte","secondByte","secondThirdBytes","Uint8ArrayToString","a","CHUNK_SZ","c","length_1","apply","subarray"],"sources":["../../../../src/core/qrcode/decoder/DecodedBitStreamParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
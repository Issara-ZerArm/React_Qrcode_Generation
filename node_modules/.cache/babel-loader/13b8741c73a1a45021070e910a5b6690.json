{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar System_1 = require(\"./util/System\");\n/**\n * <p>Encapsulates the result of decoding a barcode within an image.</p>\n *\n * @author Sean Owen\n */\n\n\nvar Result =\n/** @class */\nfunction () {\n  // public constructor(private text: string,\n  //               Uint8Array rawBytes,\n  //               ResultPoconst resultPoints: Int32Array,\n  //               BarcodeFormat format) {\n  //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n  // }\n  // public constructor(text: string,\n  //               Uint8Array rawBytes,\n  //               ResultPoconst resultPoints: Int32Array,\n  //               BarcodeFormat format,\n  //               long timestamp) {\n  //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n  //        resultPoints, format, timestamp)\n  // }\n  function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {\n    if (numBits === void 0) {\n      numBits = rawBytes == null ? 0 : 8 * rawBytes.length;\n    }\n\n    if (timestamp === void 0) {\n      timestamp = System_1.default.currentTimeMillis();\n    }\n\n    this.text = text;\n    this.rawBytes = rawBytes;\n    this.numBits = numBits;\n    this.resultPoints = resultPoints;\n    this.format = format;\n    this.timestamp = timestamp;\n    this.text = text;\n    this.rawBytes = rawBytes;\n\n    if (undefined === numBits || null === numBits) {\n      this.numBits = rawBytes === null || rawBytes === undefined ? 0 : 8 * rawBytes.length;\n    } else {\n      this.numBits = numBits;\n    }\n\n    this.resultPoints = resultPoints;\n    this.format = format;\n    this.resultMetadata = null;\n\n    if (undefined === timestamp || null === timestamp) {\n      this.timestamp = System_1.default.currentTimeMillis();\n    } else {\n      this.timestamp = timestamp;\n    }\n  }\n  /**\n   * @return raw text encoded by the barcode\n   */\n\n\n  Result.prototype.getText = function () {\n    return this.text;\n  };\n  /**\n   * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n   */\n\n\n  Result.prototype.getRawBytes = function () {\n    return this.rawBytes;\n  };\n  /**\n   * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n   * @since 3.3.0\n   */\n\n\n  Result.prototype.getNumBits = function () {\n    return this.numBits;\n  };\n  /**\n   * @return points related to the barcode in the image. These are typically points\n   *         identifying finder patterns or the corners of the barcode. The exact meaning is\n   *         specific to the type of barcode that was decoded.\n   */\n\n\n  Result.prototype.getResultPoints = function () {\n    return this.resultPoints;\n  };\n  /**\n   * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n   */\n\n\n  Result.prototype.getBarcodeFormat = function () {\n    return this.format;\n  };\n  /**\n   * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n   *   {@code null}. This contains optional metadata about what was detected about the barcode,\n   *   like orientation.\n   */\n\n\n  Result.prototype.getResultMetadata = function () {\n    return this.resultMetadata;\n  };\n\n  Result.prototype.putMetadata = function (type, value) {\n    if (this.resultMetadata === null) {\n      this.resultMetadata = new Map();\n    }\n\n    this.resultMetadata.set(type, value);\n  };\n\n  Result.prototype.putAllMetadata = function (metadata) {\n    if (metadata !== null) {\n      if (this.resultMetadata === null) {\n        this.resultMetadata = metadata;\n      } else {\n        this.resultMetadata = new Map(metadata);\n      }\n    }\n  };\n\n  Result.prototype.addResultPoints = function (newPoints) {\n    var oldPoints = this.resultPoints;\n\n    if (oldPoints === null) {\n      this.resultPoints = newPoints;\n    } else if (newPoints !== null && newPoints.length > 0) {\n      var allPoints = new Array(oldPoints.length + newPoints.length);\n      System_1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n      System_1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n      this.resultPoints = allPoints;\n    }\n  };\n\n  Result.prototype.getTimestamp = function () {\n    return this.timestamp;\n  };\n  /*@Override*/\n\n\n  Result.prototype.toString = function () {\n    return this.text;\n  };\n\n  return Result;\n}();\n\nexports.default = Result;","map":{"version":3,"mappings":"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","names":["text","rawBytes","numBits","resultPoints","format","timestamp","length","System_1","currentTimeMillis","undefined","resultMetadata","Result","type","value","Map","set","metadata","newPoints","oldPoints","allPoints","Array","arraycopy"],"sources":["../../src/core/Result.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\n/*import java.util.List;*/\n\n/**\n * <p>Encapsulates the result of decoding a matrix of bits. This typically\n * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n * as well as a String interpretation of those bytes, if applicable.</p>\n *\n * @author Sean Owen\n */\n\nvar DecoderResult =\n/** @class */\nfunction () {\n  // public constructor(rawBytes: Uint8Array,\n  //                      text: string,\n  //                      List<Uint8Array> byteSegments,\n  //                      String ecLevel) {\n  //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n  // }\n  function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {\n    if (structuredAppendSequenceNumber === void 0) {\n      structuredAppendSequenceNumber = -1;\n    }\n\n    if (structuredAppendParity === void 0) {\n      structuredAppendParity = -1;\n    }\n\n    this.rawBytes = rawBytes;\n    this.text = text;\n    this.byteSegments = byteSegments;\n    this.ecLevel = ecLevel;\n    this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n    this.structuredAppendParity = structuredAppendParity;\n    this.numBits = rawBytes === undefined || rawBytes === null ? 0 : 8 * rawBytes.length;\n  }\n  /**\n   * @return raw bytes representing the result, or {@code null} if not applicable\n   */\n\n\n  DecoderResult.prototype.getRawBytes = function () {\n    return this.rawBytes;\n  };\n  /**\n   * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n   * @since 3.3.0\n   */\n\n\n  DecoderResult.prototype.getNumBits = function () {\n    return this.numBits;\n  };\n  /**\n   * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n   * @since 3.3.0\n   */\n\n\n  DecoderResult.prototype.setNumBits = function (numBits\n  /*int*/\n  ) {\n    this.numBits = numBits;\n  };\n  /**\n   * @return text representation of the result\n   */\n\n\n  DecoderResult.prototype.getText = function () {\n    return this.text;\n  };\n  /**\n   * @return list of byte segments in the result, or {@code null} if not applicable\n   */\n\n\n  DecoderResult.prototype.getByteSegments = function () {\n    return this.byteSegments;\n  };\n  /**\n   * @return name of error correction level used, or {@code null} if not applicable\n   */\n\n\n  DecoderResult.prototype.getECLevel = function () {\n    return this.ecLevel;\n  };\n  /**\n   * @return number of errors corrected, or {@code null} if not applicable\n   */\n\n\n  DecoderResult.prototype.getErrorsCorrected = function () {\n    return this.errorsCorrected;\n  };\n\n  DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected\n  /*Integer*/\n  ) {\n    this.errorsCorrected = errorsCorrected;\n  };\n  /**\n   * @return number of erasures corrected, or {@code null} if not applicable\n   */\n\n\n  DecoderResult.prototype.getErasures = function () {\n    return this.erasures;\n  };\n\n  DecoderResult.prototype.setErasures = function (erasures\n  /*Integer*/\n  ) {\n    this.erasures = erasures;\n  };\n  /**\n   * @return arbitrary additional metadata\n   */\n\n\n  DecoderResult.prototype.getOther = function () {\n    return this.other;\n  };\n\n  DecoderResult.prototype.setOther = function (other) {\n    this.other = other;\n  };\n\n  DecoderResult.prototype.hasStructuredAppend = function () {\n    return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n  };\n\n  DecoderResult.prototype.getStructuredAppendParity = function () {\n    return this.structuredAppendParity;\n  };\n\n  DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {\n    return this.structuredAppendSequenceNumber;\n  };\n\n  return DecoderResult;\n}();\n\nexports.default = DecoderResult;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;AAgBA;;AAEA;;AAEA;;;;;;;;AAOA;AAAA;AAAA;AAOI;AACA;AACA;AACA;AACA;AACA;AAEA,yBAA2BA,QAA3B,EACYC,IADZ,EAEYC,YAFZ,EAGYC,OAHZ,EAIYC,8BAJZ,EAKYC,sBALZ,EAKuD;AAD3C;AAAAD,wCAAkD,CAAlD;AAAmD;;AACnD;AAAAC,gCAA0C,CAA1C;AAA2C;;AAL5B;AACf;AACA;AACA;AACA;AACA;AACR,SAAKC,OAAL,GAAgBN,QAAQ,KAAKO,SAAb,IAA0BP,QAAQ,KAAK,IAAxC,GAAgD,CAAhD,GAAoD,IAAIA,QAAQ,CAACQ,MAAhF;AACH;AAED;;;;;AAGOC,wCAAP;AACI,WAAO,KAAKT,QAAZ;AACH,GAFM;AAIP;;;;;;AAIOS,uCAAP;AACI,WAAO,KAAKH,OAAZ;AACH,GAFM;AAIP;;;;;;AAIOG,uCAAP,UAAkBH;AAAgB;AAAlC,IAAyC;AACrC,SAAKA,OAAL,GAAeA,OAAf;AACH,GAFM;AAIP;;;;;AAGOG,oCAAP;AACI,WAAO,KAAKR,IAAZ;AACH,GAFM;AAIP;;;;;AAGOQ,4CAAP;AACI,WAAO,KAAKP,YAAZ;AACH,GAFM;AAIP;;;;;AAGOO,uCAAP;AACI,WAAO,KAAKN,OAAZ;AACH,GAFM;AAIP;;;;;AAGOM,+CAAP;AACI,WAAO,KAAKC,eAAZ;AACH,GAFM;;AAIAD,+CAAP,UAA0BC;AAAuB;AAAjD,IAA4D;AACxD,SAAKA,eAAL,GAAuBA,eAAvB;AACH,GAFM;AAIP;;;;;AAGOD,wCAAP;AACI,WAAO,KAAKE,QAAZ;AACH,GAFM;;AAIAF,wCAAP,UAAmBE;AAAgB;AAAnC,IAA8C;AAC1C,SAAKA,QAAL,GAAgBA,QAAhB;AACH,GAFM;AAIP;;;;;AAGOF,qCAAP;AACI,WAAO,KAAKG,KAAZ;AACH,GAFM;;AAIAH,qCAAP,UAAgBG,KAAhB,EAA0B;AACtB,SAAKA,KAAL,GAAaA,KAAb;AACH,GAFM;;AAIAH,gDAAP;AACI,WAAO,KAAKJ,sBAAL,IAA+B,CAA/B,IAAoC,KAAKD,8BAAL,IAAuC,CAAlF;AACH,GAFM;;AAIAK,sDAAP;AACI,WAAO,KAAKJ,sBAAZ;AACH,GAFM;;AAIAI,8DAAP;AACI,WAAO,KAAKL,8BAAZ;AACH,GAFM;;AAIX;AAAC,CAhHD","names":["rawBytes","text","byteSegments","ecLevel","structuredAppendSequenceNumber","structuredAppendParity","numBits","undefined","length","DecoderResult","errorsCorrected","erasures","other"],"sources":["../../../src/core/common/DecoderResult.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.FormatException;\n\nvar FormatException_1 = require(\"../../FormatException\"); // import com.google.zxing.common.CharacterSetECI;\n\n\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\"); // import com.google.zxing.common.DecoderResult;\n\n\nvar DecoderResult_1 = require(\"../../common/DecoderResult\"); // import com.google.zxing.pdf417.PDF417ResultMetadata;\n\n\nvar PDF417ResultMetadata_1 = require(\"../PDF417ResultMetadata\"); // import java.io.ByteArrayOutputStream;\n// import java.math.BigInteger;\n// import java.nio.charset.Charset;\n// import java.nio.charset.StandardCharsets;\n// import java.util.Arrays;\n\n\nvar Arrays_1 = require(\"../../util/Arrays\");\n\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\n\nvar Integer_1 = require(\"../../util/Integer\");\n\nvar Long_1 = require(\"../../util/Long\");\n\nvar ByteArrayOutputStream_1 = require(\"../../util/ByteArrayOutputStream\");\n\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\n/*private*/\n\n\nvar Mode;\n\n(function (Mode) {\n  Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n  Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n  Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n  Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n  Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n  Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n})(Mode || (Mode = {}));\n/**\n * Indirectly access the global BigInt constructor, it\n * allows browsers that doesn't support BigInt to run\n * the library without breaking due to \"undefined BigInt\"\n * errors.\n */\n\n\nfunction getBigIntConstructor() {\n  if (typeof window !== 'undefined') {\n    return window['BigInt'] || null;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global['BigInt'] || null;\n  }\n\n  throw new Error('Can\\'t search globals for BigInt!');\n}\n/**\n * Used to store the BigInt constructor.\n */\n\n\nvar BigInteger;\n/**\n * This function creates a bigint value. It allows browsers\n * that doesn't support BigInt to run the rest of the library\n * by not directly accessing the BigInt constructor.\n */\n\nfunction createBigInt(num) {\n  if (typeof BigInteger === 'undefined') {\n    BigInteger = getBigIntConstructor();\n  }\n\n  if (BigInteger === null) {\n    throw new Error('BigInt is not supported!');\n  }\n\n  return BigInteger(num);\n}\n\nfunction getEXP900() {\n  // in Java - array with length = 16\n  var EXP900 = [];\n  EXP900[0] = createBigInt(1);\n  var nineHundred = createBigInt(900);\n  EXP900[1] = nineHundred; // in Java - array with length = 16\n\n  for (var i\n  /*int*/\n  = 2; i < 16; i++) {\n    EXP900[i] = EXP900[i - 1] * nineHundred;\n  }\n\n  return EXP900;\n}\n/**\n * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n *\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author Guenther Grau\n */\n\n\nvar DecodedBitStreamParser =\n/** @class */\nfunction () {\n  function DecodedBitStreamParser() {} //   private DecodedBitStreamParser() {\n  // }\n\n  /**\n   *\n   * @param codewords\n   * @param ecLevel\n   *\n   * @throws FormatException\n   */\n\n\n  DecodedBitStreamParser.decode = function (codewords, ecLevel) {\n    // pass encoding to result (will be used for decode symbols in byte mode)\n    var result = new StringBuilder_1.default(''); // let encoding: Charset = StandardCharsets.ISO_8859_1;\n\n    var encoding = CharacterSetECI_1.default.ISO8859_1;\n    /**\n     * @note the next command is specific from this TypeScript library\n     * because TS can't properly cast some values to char and\n     * convert it to string later correctly due to encoding\n     * differences from Java version. As reported here:\n     * https://github.com/zxing-js/library/pull/264/files#r382831593\n     */\n\n    result.enableDecoding(encoding); // Get compaction mode\n\n    var codeIndex = 1;\n    var code = codewords[codeIndex++];\n    var resultMetadata = new PDF417ResultMetadata_1.default();\n\n    while (codeIndex < codewords[0]) {\n      switch (code) {\n        case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n          codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n          break;\n\n        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n          codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);\n          break;\n\n        case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n          result.append(\n          /*(char)*/\n          codewords[codeIndex++]);\n          break;\n\n        case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n          codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);\n          break;\n\n        case DecodedBitStreamParser.ECI_CHARSET:\n          var charsetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(codewords[codeIndex++]); // encoding = Charset.forName(charsetECI.getName());\n\n          break;\n\n        case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:\n          // Can't do anything with generic ECI; skip its 2 characters\n          codeIndex += 2;\n          break;\n\n        case DecodedBitStreamParser.ECI_USER_DEFINED:\n          // Can't do anything with user ECI; skip its 1 character\n          codeIndex++;\n          break;\n\n        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n          codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n          break;\n\n        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n          // Should not see these outside a macro block\n          throw new FormatException_1.default();\n\n        default:\n          // Default to text compaction. During testing numerous barcodes\n          // appeared to be missing the starting mode. In these cases defaulting\n          // to text compaction seems to work.\n          codeIndex--;\n          codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);\n          break;\n      }\n\n      if (codeIndex < codewords.length) {\n        code = codewords[codeIndex++];\n      } else {\n        throw FormatException_1.default.getFormatInstance();\n      }\n    }\n\n    if (result.length() === 0) {\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    var decoderResult = new DecoderResult_1.default(null, result.toString(), null, ecLevel);\n    decoderResult.setOther(resultMetadata);\n    return decoderResult;\n  };\n  /**\n   *\n   * @param int\n   * @param param1\n   * @param codewords\n   * @param int\n   * @param codeIndex\n   * @param PDF417ResultMetadata\n   * @param resultMetadata\n   *\n   * @throws FormatException\n   */\n  // @SuppressWarnings(\"deprecation\")\n\n\n  DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {\n    if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n      // we must have at least two bytes left for the segment index\n      throw FormatException_1.default.getFormatInstance();\n    }\n\n    var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);\n\n    for (var i\n    /*int*/\n    = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {\n      segmentIndexArray[i] = codewords[codeIndex];\n    }\n\n    resultMetadata.setSegmentIndex(Integer_1.default.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));\n    var fileId = new StringBuilder_1.default();\n    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);\n    resultMetadata.setFileId(fileId.toString());\n    var optionalFieldsStart = -1;\n\n    if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n      optionalFieldsStart = codeIndex + 1;\n    }\n\n    while (codeIndex < codewords[0]) {\n      switch (codewords[codeIndex]) {\n        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n          codeIndex++;\n\n          switch (codewords[codeIndex]) {\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n              var fileName = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);\n              resultMetadata.setFileName(fileName.toString());\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n              var sender = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);\n              resultMetadata.setSender(sender.toString());\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n              var addressee = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);\n              resultMetadata.setAddressee(addressee.toString());\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n              var segmentCount = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);\n              resultMetadata.setSegmentCount(Integer_1.default.parseInt(segmentCount.toString()));\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n              var timestamp = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);\n              resultMetadata.setTimestamp(Long_1.default.parseLong(timestamp.toString()));\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n              var checksum = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);\n              resultMetadata.setChecksum(Integer_1.default.parseInt(checksum.toString()));\n              break;\n\n            case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n              var fileSize = new StringBuilder_1.default();\n              codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);\n              resultMetadata.setFileSize(Long_1.default.parseLong(fileSize.toString()));\n              break;\n\n            default:\n              throw FormatException_1.default.getFormatInstance();\n          }\n\n          break;\n\n        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n          codeIndex++;\n          resultMetadata.setLastSegment(true);\n          break;\n\n        default:\n          throw FormatException_1.default.getFormatInstance();\n      }\n    } // copy optional fields to additional options\n\n\n    if (optionalFieldsStart !== -1) {\n      var optionalFieldsLength = codeIndex - optionalFieldsStart;\n\n      if (resultMetadata.isLastSegment()) {\n        // do not include terminator\n        optionalFieldsLength--;\n      }\n\n      resultMetadata.setOptionalData(Arrays_1.default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n    }\n\n    return codeIndex;\n  };\n  /**\n   * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n   * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n   * well as selected control characters.\n   *\n   * @param codewords The array of codewords (data + error)\n   * @param codeIndex The current index into the codeword array.\n   * @param result    The decoded data is appended to the result.\n   * @return The next index into the codeword array.\n   */\n\n\n  DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {\n    // 2 character per codeword\n    var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2); // Used to hold the byte compaction value if there is a mode shift\n\n    var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n    var index = 0;\n    var end = false;\n\n    while (codeIndex < codewords[0] && !end) {\n      var code = codewords[codeIndex++];\n\n      if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n        textCompactionData[index] = code / 30;\n        textCompactionData[index + 1] = code % 30;\n        index += 2;\n      } else {\n        switch (code) {\n          case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n            // reinitialize text compaction mode to alpha sub mode\n            textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;\n            break;\n\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n          case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n          case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n            codeIndex--;\n            end = true;\n            break;\n\n          case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n            // The Mode Shift codeword 913 shall cause a temporary\n            // switch from Text Compaction mode to Byte Compaction mode.\n            // This switch shall be in effect for only the next codeword,\n            // after which the mode shall revert to the prevailing sub-mode\n            // of the Text Compaction mode. Codeword 913 is only available\n            // in Text Compaction mode; its use is described in 5.4.2.4.\n            textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n            code = codewords[codeIndex++];\n            byteCompactionData[index] = code;\n            index++;\n            break;\n        }\n      }\n    }\n\n    DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n    return codeIndex;\n  };\n  /**\n   * The Text Compaction mode includes all the printable ASCII characters\n   * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n   * (9: e), LF or line feed (10: e), and CR or carriage\n   * return (13: e). The Text Compaction mode also includes various latch\n   * and shift characters which are used exclusively within the mode. The Text\n   * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n   * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n   * switches are defined in 5.4.2.3.\n   *\n   * @param textCompactionData The text compaction data.\n   * @param byteCompactionData The byte compaction data if there\n   *                           was a mode shift.\n   * @param length             The size of the text compaction and byte compaction data.\n   * @param result             The decoded data is appended to the result.\n   */\n\n\n  DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {\n    // Beginning from an initial state of the Alpha sub-mode\n    // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n    // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n    // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n    var subMode = Mode.ALPHA;\n    var priorToShiftMode = Mode.ALPHA;\n    var i = 0;\n\n    while (i < length) {\n      var subModeCh = textCompactionData[i];\n      var ch =\n      /*char*/\n      '';\n\n      switch (subMode) {\n        case Mode.ALPHA:\n          // Alpha (alphabetic: uppercase)\n          if (subModeCh < 26) {\n            // Upper case Alpha Character\n            // Note: 65 = 'A' ASCII -> there is byte code of symbol\n            ch =\n            /*(char)('A' + subModeCh) */\n            String.fromCharCode(65 + subModeCh);\n          } else {\n            switch (subModeCh) {\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.LL:\n                subMode = Mode.LOWER;\n                break;\n\n              case DecodedBitStreamParser.ML:\n                subMode = Mode.MIXED;\n                break;\n\n              case DecodedBitStreamParser.PS:\n                // Shift to punctuation\n                priorToShiftMode = subMode;\n                subMode = Mode.PUNCT_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.LOWER:\n          // Lower (alphabetic: lowercase)\n          if (subModeCh < 26) {\n            ch =\n            /*(char)('a' + subModeCh)*/\n            String.fromCharCode(97 + subModeCh);\n          } else {\n            switch (subModeCh) {\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.AS:\n                // Shift to alpha\n                priorToShiftMode = subMode;\n                subMode = Mode.ALPHA_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.ML:\n                subMode = Mode.MIXED;\n                break;\n\n              case DecodedBitStreamParser.PS:\n                // Shift to punctuation\n                priorToShiftMode = subMode;\n                subMode = Mode.PUNCT_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                // TODO Does this need to use the current character encoding? See other occurrences below\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.MIXED:\n          // Mixed (punctuation: e)\n          if (subModeCh < DecodedBitStreamParser.PL) {\n            ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];\n          } else {\n            switch (subModeCh) {\n              case DecodedBitStreamParser.PL:\n                subMode = Mode.PUNCT;\n                break;\n\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.LL:\n                subMode = Mode.LOWER;\n                break;\n\n              case DecodedBitStreamParser.AL:\n                subMode = Mode.ALPHA;\n                break;\n\n              case DecodedBitStreamParser.PS:\n                // Shift to punctuation\n                priorToShiftMode = subMode;\n                subMode = Mode.PUNCT_SHIFT;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.PUNCT:\n          // Punctuation\n          if (subModeCh < DecodedBitStreamParser.PAL) {\n            ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n          } else {\n            switch (subModeCh) {\n              case DecodedBitStreamParser.PAL:\n                subMode = Mode.ALPHA;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.ALPHA_SHIFT:\n          // Restore sub-mode\n          subMode = priorToShiftMode;\n\n          if (subModeCh < 26) {\n            ch =\n            /*(char)('A' + subModeCh)*/\n            String.fromCharCode(65 + subModeCh);\n          } else {\n            switch (subModeCh) {\n              case 26:\n                ch = ' ';\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n\n        case Mode.PUNCT_SHIFT:\n          // Restore sub-mode\n          subMode = priorToShiftMode;\n\n          if (subModeCh < DecodedBitStreamParser.PAL) {\n            ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];\n          } else {\n            switch (subModeCh) {\n              case DecodedBitStreamParser.PAL:\n                subMode = Mode.ALPHA;\n                break;\n\n              case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                // PS before Shift-to-Byte is used as a padding character,\n                // see 5.4.2.4 of the specification\n                result.append(\n                /*(char)*/\n                byteCompactionData[i]);\n                break;\n\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n                subMode = Mode.ALPHA;\n                break;\n            }\n          }\n\n          break;\n      } // if (ch !== 0) {\n\n\n      if (ch !== '') {\n        // Append decoded character to result\n        result.append(ch);\n      }\n\n      i++;\n    }\n  };\n  /**\n   * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n   * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n   * character set support.\n   *\n   * @param mode      The byte compaction mode i.e. 901 or 924\n   * @param codewords The array of codewords (data + error)\n   * @param encoding  Currently active character encoding\n   * @param codeIndex The current index into the codeword array.\n   * @param result    The decoded data is appended to the result.\n   * @return The next index into the codeword array.\n   */\n\n\n  DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {\n    var decodedBytes = new ByteArrayOutputStream_1.default();\n    var count = 0;\n    var value =\n    /*long*/\n    0;\n    var end = false;\n\n    switch (mode) {\n      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n        // Total number of Byte Compaction characters to be encoded\n        // is not a multiple of 6\n        var byteCompactedCodewords = new Int32Array(6);\n        var nextCode = codewords[codeIndex++];\n\n        while (codeIndex < codewords[0] && !end) {\n          byteCompactedCodewords[count++] = nextCode; // Base 900\n\n          value = 900 * value + nextCode;\n          nextCode = codewords[codeIndex++]; // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n\n          switch (nextCode) {\n            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n            case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n            case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n              codeIndex--;\n              end = true;\n              break;\n\n            default:\n              if (count % 5 === 0 && count > 0) {\n                // Decode every 5 codewords\n                // Convert to Base 256\n                for (var j\n                /*int*/\n                = 0; j < 6; ++j) {\n                  /* @note\n                   * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                   * So the next bitwise operation could not be done with simple numbers\n                   */\n                  decodedBytes.write(\n                  /*(byte)*/\n                  Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                }\n\n                value = 0;\n                count = 0;\n              }\n\n              break;\n          }\n        } // if the end of all codewords is reached the last codeword needs to be added\n\n\n        if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n          byteCompactedCodewords[count++] = nextCode;\n        } // If Byte Compaction mode is invoked with codeword 901,\n        // the last group of codewords is interpreted directly\n        // as one byte per codeword, without compaction.\n\n\n        for (var i\n        /*int*/\n        = 0; i < count; i++) {\n          decodedBytes.write(\n          /*(byte)*/\n          byteCompactedCodewords[i]);\n        }\n\n        break;\n\n      case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n        // Total number of Byte Compaction characters to be encoded\n        // is an integer multiple of 6\n        while (codeIndex < codewords[0] && !end) {\n          var code = codewords[codeIndex++];\n\n          if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n            count++; // Base 900\n\n            value = 900 * value + code;\n          } else {\n            switch (code) {\n              case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n              case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:\n              case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n              case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n              case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n              case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n                codeIndex--;\n                end = true;\n                break;\n            }\n          }\n\n          if (count % 5 === 0 && count > 0) {\n            // Decode every 5 codewords\n            // Convert to Base 256\n\n            /* @note\n             * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n             * So the next bitwise operation could not be done with simple numbers\n            */\n            for (var j\n            /*int*/\n            = 0; j < 6; ++j) {\n              decodedBytes.write(\n              /*(byte)*/\n              Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n            }\n\n            value = 0;\n            count = 0;\n          }\n        }\n\n        break;\n    }\n\n    result.append(StringEncoding_1.default.decode(decodedBytes.toByteArray(), encoding));\n    return codeIndex;\n  };\n  /**\n   * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n   *\n   * @param codewords The array of codewords (data + error)\n   * @param codeIndex The current index into the codeword array.\n   * @param result    The decoded data is appended to the result.\n   * @return The next index into the codeword array.\n   *\n   * @throws FormatException\n   */\n\n\n  DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex\n  /*int*/\n  , result) {\n    var count = 0;\n    var end = false;\n    var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);\n\n    while (codeIndex < codewords[0] && !end) {\n      var code = codewords[codeIndex++];\n\n      if (codeIndex === codewords[0]) {\n        end = true;\n      }\n\n      if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {\n        numericCodewords[count] = code;\n        count++;\n      } else {\n        switch (code) {\n          case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:\n          case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n          case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n          case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:\n            codeIndex--;\n            end = true;\n            break;\n        }\n      }\n\n      if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n        // Re-invoking Numeric Compaction mode (by using codeword 902\n        // while in Numeric Compaction mode) serves  to terminate the\n        // current Numeric Compaction mode grouping as described in 5.4.4.2,\n        // and then to start a new one grouping.\n        result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));\n        count = 0;\n      }\n    }\n\n    return codeIndex;\n  };\n  /**\n   * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n   *\n   * @param codewords The array of codewords\n   * @param count     The number of codewords\n   * @return The decoded string representing the Numeric data.\n   *\n   * EXAMPLE\n   * Encode the fifteen digit numeric string 000213298174000\n   * Prefix the numeric string with a 1 and set the initial value of\n   * t = 1 000 213 298 174 000\n   * Calculate codeword 0\n   * d0 = 1 000 213 298 174 000 mod 900 = 200\n   *\n   * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n   * Calculate codeword 1\n   * d1 = 1 111 348 109 082 mod 900 = 282\n   *\n   * t = 1 111 348 109 082 div 900 = 1 234 831 232\n   * Calculate codeword 2\n   * d2 = 1 234 831 232 mod 900 = 632\n   *\n   * t = 1 234 831 232 div 900 = 1 372 034\n   * Calculate codeword 3\n   * d3 = 1 372 034 mod 900 = 434\n   *\n   * t = 1 372 034 div 900 = 1 524\n   * Calculate codeword 4\n   * d4 = 1 524 mod 900 = 624\n   *\n   * t = 1 524 div 900 = 1\n   * Calculate codeword 5\n   * d5 = 1 mod 900 = 1\n   * t = 1 div 900 = 0\n   * Codeword sequence is: 1, 624, 434, 632, 282, 200\n   *\n   * Decode the above codewords involves\n   *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n   * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n   *\n   * Remove leading 1 =>  Result is 000213298174000\n   *\n   * @throws FormatException\n   */\n\n\n  DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {\n    var result = createBigInt(0);\n\n    for (var i\n    /*int*/\n    = 0; i < count; i++) {\n      result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);\n    }\n\n    var resultString = result.toString();\n\n    if (resultString.charAt(0) !== '1') {\n      throw new FormatException_1.default();\n    }\n\n    return resultString.substring(1);\n  };\n\n  DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;\n  DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;\n  DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;\n  DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n  DecodedBitStreamParser.ECI_USER_DEFINED = 925;\n  DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;\n  DecodedBitStreamParser.ECI_CHARSET = 927;\n  DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n  DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n  DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;\n  DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n  DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n  DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n  DecodedBitStreamParser.PL = 25;\n  DecodedBitStreamParser.LL = 27;\n  DecodedBitStreamParser.AS = 27;\n  DecodedBitStreamParser.ML = 28;\n  DecodedBitStreamParser.AL = 28;\n  DecodedBitStreamParser.PS = 29;\n  DecodedBitStreamParser.PAL = 29;\n  DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\\\]_`~!\\r\\t,:\\n-.$/\"|*()?{}\\'';\n  DecodedBitStreamParser.MIXED_CHARS = '0123456789&\\r\\t,:#-.$/+%*=^';\n  /**\n   * Table containing values for the exponent of 900.\n   * This is used in the numeric compaction decode algorithm.\n   */\n\n  DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n  DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n  return DecodedBitStreamParser;\n}();\n\nexports.default = DecodedBitStreamParser;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;IAgBA;AAEA;;AACA,yD,CACA;;;AACA,gE,CACA;;;AACA,4D,CACA;;;AACA,gE,CAEA;AACA;AACA;AACA;AACA;;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;AAKA;;;AAAY,IAAKA,IAAL;;AAAA,WAAKA,IAAL,EAAS;AACnBA;AACAA;AACAA;AACAA;AACAA;AACAA;AACD,CAPW,EAAKA,IAAI,KAAJA,IAAI,MAAT;AASZ;;;;;;;;AAMA,SAASC,oBAAT,GAA6B;AAE3B,MAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AACjC,WAAOA,MAAM,CAAC,QAAD,CAAN,IAAoB,IAA3B;AACD;;AAED,MAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AACjC,WAAOA,MAAM,CAAC,QAAD,CAAN,IAAoB,IAA3B;AACD;;AAED,QAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;AACD;AAED;;;;;AAGA,IAAIC,UAAJ;AAEA;;;;;;AAKA,SAASC,YAAT,CAAsBC,GAAtB,EAAmD;AAEjD,MAAI,OAAOF,UAAP,KAAsB,WAA1B,EAAuC;AACrCA,cAAU,GAAGJ,oBAAoB,EAAjC;AACD;;AAED,MAAII,UAAU,KAAK,IAAnB,EAAyB;AACvB,UAAM,IAAID,KAAJ,CAAU,0BAAV,CAAN;AACD;;AAED,SAAOC,UAAU,CAACE,GAAD,CAAjB;AACD;;AAED,SAASC,SAAT,GAAkB;AAChB;AACA,MAAIC,MAAM,GAAG,EAAb;AAEAA,QAAM,CAAC,CAAD,CAAN,GAAYH,YAAY,CAAC,CAAD,CAAxB;AAEA,MAAII,WAAW,GAAGJ,YAAY,CAAC,GAAD,CAA9B;AAEAG,QAAM,CAAC,CAAD,CAAN,GAAYC,WAAZ,CARgB,CAUhB;;AACA,OAAK,IAAIC;AAAE;AAAD,IAAW,CAArB,EAAwBA,CAAC,GAAG,EAA5B,EAAgCA,CAAC,EAAjC,EAAqC;AACnCF,UAAM,CAACE,CAAD,CAAN,GAAYF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBD,WAA5B;AACD;;AAED,SAAOD,MAAP;AACD;AAED;;;;;;;;AAMA;AAAA;AAAA;AAAA,qCAqsBC,CArsBD,CA6CE;AACA;;AAEA;;;;;;;;;AAOOG,kCAAP,UAAcC,SAAd,EAAqCC,OAArC,EAAoD;AAClD;AACA,QAAIC,MAAM,GAAkB,IAAIC,uBAAJ,CAAkB,EAAlB,CAA5B,CAFkD,CAGlD;;AACA,QAAIC,QAAQ,GAAGC,0BAAgBC,SAA/B;AACA;;;;;;;;AAOAJ,UAAM,CAACK,cAAP,CAAsBH,QAAtB,EAZkD,CAalD;;AACA,QAAII,SAAS,GAAQ,CAArB;AACA,QAAIC,IAAI,GAAQT,SAAS,CAACQ,SAAS,EAAV,CAAzB;AACA,QAAIE,cAAc,GAAyB,IAAIC,8BAAJ,EAA3C;;AACA,WAAOH,SAAS,GAAGR,SAAS,CAAC,CAAD,CAA5B,EAAiC;AAC/B,cAAQS,IAAR;AACE,aAAKV,sBAAsB,CAACa,0BAA5B;AACEJ,mBAAS,GAAGT,sBAAsB,CAACc,cAAvB,CAAsCb,SAAtC,EAAiDQ,SAAjD,EAA4DN,MAA5D,CAAZ;AACA;;AACF,aAAKH,sBAAsB,CAACe,0BAA5B;AACA,aAAKf,sBAAsB,CAACgB,4BAA5B;AACEP,mBAAS,GAAGT,sBAAsB,CAACiB,cAAvB,CAAsCP,IAAtC,EAA4CT,SAA5C,EAAuDI,QAAvD,EAAiEI,SAAjE,EAA4EN,MAA5E,CAAZ;AACA;;AACF,aAAKH,sBAAsB,CAACkB,kCAA5B;AACEf,gBAAM,CAACgB,MAAP;AAAc;AAAWlB,mBAAS,CAACQ,SAAS,EAAV,CAAlC;AACA;;AACF,aAAKT,sBAAsB,CAACoB,6BAA5B;AACEX,mBAAS,GAAGT,sBAAsB,CAACqB,iBAAvB,CAAyCpB,SAAzC,EAAoDQ,SAApD,EAA+DN,MAA/D,CAAZ;AACA;;AACF,aAAKH,sBAAsB,CAACsB,WAA5B;AACE,cAAIC,UAAU,GACZjB,0BAAgBkB,yBAAhB,CAA0CvB,SAAS,CAACQ,SAAS,EAAV,CAAnD,CADF,CADF,CAGE;;AACA;;AACF,aAAKT,sBAAsB,CAACyB,mBAA5B;AACE;AACAhB,mBAAS,IAAI,CAAb;AACA;;AACF,aAAKT,sBAAsB,CAAC0B,gBAA5B;AACE;AACAjB,mBAAS;AACT;;AACF,aAAKT,sBAAsB,CAAC2B,gCAA5B;AACElB,mBAAS,GAAGT,sBAAsB,CAAC4B,gBAAvB,CAAwC3B,SAAxC,EAAmDQ,SAAnD,EAA8DE,cAA9D,CAAZ;AACA;;AACF,aAAKX,sBAAsB,CAAC6B,iCAA5B;AACA,aAAK7B,sBAAsB,CAAC8B,uBAA5B;AACE;AACA,gBAAM,IAAIC,yBAAJ,EAAN;;AACF;AACE;AACA;AACA;AACAtB,mBAAS;AACTA,mBAAS,GAAGT,sBAAsB,CAACc,cAAvB,CAAsCb,SAAtC,EAAiDQ,SAAjD,EAA4DN,MAA5D,CAAZ;AACA;AAxCJ;;AA0CA,UAAIM,SAAS,GAAGR,SAAS,CAAC+B,MAA1B,EAAkC;AAChCtB,YAAI,GAAGT,SAAS,CAACQ,SAAS,EAAV,CAAhB;AACD,OAFD,MAEO;AACL,cAAMsB,0BAAgBE,iBAAhB,EAAN;AACD;AACF;;AACD,QAAI9B,MAAM,CAAC6B,MAAP,OAAoB,CAAxB,EAA2B;AACzB,YAAMD,0BAAgBE,iBAAhB,EAAN;AACD;;AACD,QAAIC,aAAa,GAAkB,IAAIC,uBAAJ,CAAkB,IAAlB,EAAwBhC,MAAM,CAACiC,QAAP,EAAxB,EAA2C,IAA3C,EAAiDlC,OAAjD,CAAnC;AACAgC,iBAAa,CAACG,QAAd,CAAuB1B,cAAvB;AACA,WAAOuB,aAAP;AACD,GAxEM;AA0EP;;;;;;;;;;;;AAYA;;;AACOlC,4CAAP,UAAwBC,SAAxB,EAA+CQ,SAA/C,EAA+DE,cAA/D,EAAmG;AACjG,QAAIF,SAAS,GAAGT,sBAAsB,CAACsC,4BAAnC,GAAkErC,SAAS,CAAC,CAAD,CAA/E,EAAoF;AAClF;AACA,YAAM8B,0BAAgBE,iBAAhB,EAAN;AACD;;AACD,QAAIM,iBAAiB,GAAe,IAAIC,UAAJ,CAAexC,sBAAsB,CAACsC,4BAAtC,CAApC;;AACA,SAAK,IAAIvC;AAAE;AAAD,MAAW,CAArB,EAAwBA,CAAC,GAAGC,sBAAsB,CAACsC,4BAAnD,EAAiFvC,CAAC,IAAIU,SAAS,EAA/F,EAAmG;AACjG8B,uBAAiB,CAACxC,CAAD,CAAjB,GAAuBE,SAAS,CAACQ,SAAD,CAAhC;AACD;;AACDE,kBAAc,CAAC8B,eAAf,CAA+BC,kBAAQC,QAAR,CAAiB3C,sBAAsB,CAAC4C,qBAAvB,CAA6CL,iBAA7C,EAC9CvC,sBAAsB,CAACsC,4BADuB,CAAjB,CAA/B;AAGA,QAAIO,MAAM,GAAkB,IAAIzC,uBAAJ,EAA5B;AACAK,aAAS,GAAGT,sBAAsB,CAACc,cAAvB,CAAsCb,SAAtC,EAAiDQ,SAAjD,EAA4DoC,MAA5D,CAAZ;AACAlC,kBAAc,CAACmC,SAAf,CAAyBD,MAAM,CAACT,QAAP,EAAzB;AAEA,QAAIW,mBAAmB,GAAQ,CAAC,CAAhC;;AACA,QAAI9C,SAAS,CAACQ,SAAD,CAAT,KAAyBT,sBAAsB,CAAC6B,iCAApD,EAAuF;AACrFkB,yBAAmB,GAAGtC,SAAS,GAAG,CAAlC;AACD;;AAED,WAAOA,SAAS,GAAGR,SAAS,CAAC,CAAD,CAA5B,EAAiC;AAC/B,cAAQA,SAAS,CAACQ,SAAD,CAAjB;AACE,aAAKT,sBAAsB,CAAC6B,iCAA5B;AACEpB,mBAAS;;AACT,kBAAQR,SAAS,CAACQ,SAAD,CAAjB;AACE,iBAAKT,sBAAsB,CAACgD,qCAA5B;AACE,kBAAIC,QAAQ,GAAkB,IAAI7C,uBAAJ,EAA9B;AACAK,uBAAS,GAAGT,sBAAsB,CAACc,cAAvB,CAAsCb,SAAtC,EAAiDQ,SAAS,GAAG,CAA7D,EAAgEwC,QAAhE,CAAZ;AACAtC,4BAAc,CAACuC,WAAf,CAA2BD,QAAQ,CAACb,QAAT,EAA3B;AACA;;AACF,iBAAKpC,sBAAsB,CAACmD,kCAA5B;AACE,kBAAIC,MAAM,GAAkB,IAAIhD,uBAAJ,EAA5B;AACAK,uBAAS,GAAGT,sBAAsB,CAACc,cAAvB,CAAsCb,SAAtC,EAAiDQ,SAAS,GAAG,CAA7D,EAAgE2C,MAAhE,CAAZ;AACAzC,4BAAc,CAAC0C,SAAf,CAAyBD,MAAM,CAAChB,QAAP,EAAzB;AACA;;AACF,iBAAKpC,sBAAsB,CAACsD,qCAA5B;AACE,kBAAIC,SAAS,GAAkB,IAAInD,uBAAJ,EAA/B;AACAK,uBAAS,GAAGT,sBAAsB,CAACc,cAAvB,CAAsCb,SAAtC,EAAiDQ,SAAS,GAAG,CAA7D,EAAgE8C,SAAhE,CAAZ;AACA5C,4BAAc,CAAC6C,YAAf,CAA4BD,SAAS,CAACnB,QAAV,EAA5B;AACA;;AACF,iBAAKpC,sBAAsB,CAACyD,yCAA5B;AACE,kBAAIC,YAAY,GAAkB,IAAItD,uBAAJ,EAAlC;AACAK,uBAAS,GAAGT,sBAAsB,CAACqB,iBAAvB,CAAyCpB,SAAzC,EAAoDQ,SAAS,GAAG,CAAhE,EAAmEiD,YAAnE,CAAZ;AACA/C,4BAAc,CAACgD,eAAf,CAA+BjB,kBAAQC,QAAR,CAAiBe,YAAY,CAACtB,QAAb,EAAjB,CAA/B;AACA;;AACF,iBAAKpC,sBAAsB,CAAC4D,sCAA5B;AACE,kBAAIC,SAAS,GAAkB,IAAIzD,uBAAJ,EAA/B;AACAK,uBAAS,GAAGT,sBAAsB,CAACqB,iBAAvB,CAAyCpB,SAAzC,EAAoDQ,SAAS,GAAG,CAAhE,EAAmEoD,SAAnE,CAAZ;AACAlD,4BAAc,CAACmD,YAAf,CAA4BC,eAAKC,SAAL,CAAeH,SAAS,CAACzB,QAAV,EAAf,CAA5B;AACA;;AACF,iBAAKpC,sBAAsB,CAACiE,oCAA5B;AACE,kBAAIC,QAAQ,GAAkB,IAAI9D,uBAAJ,EAA9B;AACAK,uBAAS,GAAGT,sBAAsB,CAACqB,iBAAvB,CAAyCpB,SAAzC,EAAoDQ,SAAS,GAAG,CAAhE,EAAmEyD,QAAnE,CAAZ;AACAvD,4BAAc,CAACwD,WAAf,CAA2BzB,kBAAQC,QAAR,CAAiBuB,QAAQ,CAAC9B,QAAT,EAAjB,CAA3B;AACA;;AACF,iBAAKpC,sBAAsB,CAACoE,qCAA5B;AACE,kBAAIC,QAAQ,GAAkB,IAAIjE,uBAAJ,EAA9B;AACAK,uBAAS,GAAGT,sBAAsB,CAACqB,iBAAvB,CAAyCpB,SAAzC,EAAoDQ,SAAS,GAAG,CAAhE,EAAmE4D,QAAnE,CAAZ;AACA1D,4BAAc,CAAC2D,WAAf,CAA2BP,eAAKC,SAAL,CAAeK,QAAQ,CAACjC,QAAT,EAAf,CAA3B;AACA;;AACF;AACE,oBAAML,0BAAgBE,iBAAhB,EAAN;AArCJ;;AAuCA;;AACF,aAAKjC,sBAAsB,CAAC8B,uBAA5B;AACErB,mBAAS;AACTE,wBAAc,CAAC4D,cAAf,CAA8B,IAA9B;AACA;;AACF;AACE,gBAAMxC,0BAAgBE,iBAAhB,EAAN;AAhDJ;AAkDD,KAxEgG,CA0EjG;;;AACA,QAAIc,mBAAmB,KAAK,CAAC,CAA7B,EAAgC;AAC9B,UAAIyB,oBAAoB,GAAQ/D,SAAS,GAAGsC,mBAA5C;;AACA,UAAIpC,cAAc,CAAC8D,aAAf,EAAJ,EAAoC;AAClC;AACAD,4BAAoB;AACrB;;AACD7D,oBAAc,CAAC+D,eAAf,CAA+BC,iBAAOC,WAAP,CAAmB3E,SAAnB,EAA8B8C,mBAA9B,EAAmDA,mBAAmB,GAAGyB,oBAAzE,CAA/B;AACD;;AAED,WAAO/D,SAAP;AACD,GArFM;AAuFP;;;;;;;;;;;;AAUeT,0CAAf,UAA8BC,SAA9B,EAAqDQ,SAArD,EAAqEN,MAArE,EAA0F;AACxF;AACA,QAAI0E,kBAAkB,GAAe,IAAIrC,UAAJ,CAAe,CAACvC,SAAS,CAAC,CAAD,CAAT,GAAeQ,SAAhB,IAA6B,CAA5C,CAArC,CAFwF,CAGxF;;AACA,QAAIqE,kBAAkB,GAAe,IAAItC,UAAJ,CAAe,CAACvC,SAAS,CAAC,CAAD,CAAT,GAAeQ,SAAhB,IAA6B,CAA5C,CAArC;AAEA,QAAIsE,KAAK,GAAQ,CAAjB;AACA,QAAIC,GAAG,GAAY,KAAnB;;AACA,WAAQvE,SAAS,GAAGR,SAAS,CAAC,CAAD,CAAtB,IAA8B,CAAC+E,GAAtC,EAA2C;AACzC,UAAItE,IAAI,GAAQT,SAAS,CAACQ,SAAS,EAAV,CAAzB;;AACA,UAAIC,IAAI,GAAGV,sBAAsB,CAACa,0BAAlC,EAA8D;AAC5DgE,0BAAkB,CAACE,KAAD,CAAlB,GAA4BrE,IAAI,GAAG,EAAnC;AACAmE,0BAAkB,CAACE,KAAK,GAAG,CAAT,CAAlB,GAAgCrE,IAAI,GAAG,EAAvC;AACAqE,aAAK,IAAI,CAAT;AACD,OAJD,MAIO;AACL,gBAAQrE,IAAR;AACE,eAAKV,sBAAsB,CAACa,0BAA5B;AACE;AACAgE,8BAAkB,CAACE,KAAK,EAAN,CAAlB,GAA8B/E,sBAAsB,CAACa,0BAArD;AACA;;AACF,eAAKb,sBAAsB,CAACe,0BAA5B;AACA,eAAKf,sBAAsB,CAACgB,4BAA5B;AACA,eAAKhB,sBAAsB,CAACoB,6BAA5B;AACA,eAAKpB,sBAAsB,CAAC2B,gCAA5B;AACA,eAAK3B,sBAAsB,CAAC6B,iCAA5B;AACA,eAAK7B,sBAAsB,CAAC8B,uBAA5B;AACErB,qBAAS;AACTuE,eAAG,GAAG,IAAN;AACA;;AACF,eAAKhF,sBAAsB,CAACkB,kCAA5B;AACE;AACA;AACA;AACA;AACA;AACA;AACA2D,8BAAkB,CAACE,KAAD,CAAlB,GAA4B/E,sBAAsB,CAACkB,kCAAnD;AACAR,gBAAI,GAAGT,SAAS,CAACQ,SAAS,EAAV,CAAhB;AACAqE,8BAAkB,CAACC,KAAD,CAAlB,GAA4BrE,IAA5B;AACAqE,iBAAK;AACL;AAzBJ;AA2BD;AACF;;AACD/E,0BAAsB,CAACiF,oBAAvB,CAA4CJ,kBAA5C,EAAgEC,kBAAhE,EAAoFC,KAApF,EAA2F5E,MAA3F;AACA,WAAOM,SAAP;AACD,GA9Cc;AAgDf;;;;;;;;;;;;;;;;;;AAgBeT,gDAAf,UAAoC6E,kBAApC,EACEC,kBADF,EAEE9C,MAFF,EAGE7B,MAHF,EAGuB;AACrB;AACA;AACA;AACA;AACA,QAAI+E,OAAO,GAAS9F,IAAI,CAAC+F,KAAzB;AACA,QAAIC,gBAAgB,GAAShG,IAAI,CAAC+F,KAAlC;AACA,QAAIpF,CAAC,GAAQ,CAAb;;AACA,WAAOA,CAAC,GAAGiC,MAAX,EAAmB;AACjB,UAAIqD,SAAS,GAAQR,kBAAkB,CAAC9E,CAAD,CAAvC;AACA,UAAIuF,EAAE;AAAE;AAAkB,QAA1B;;AACA,cAAQJ,OAAR;AACE,aAAK9F,IAAI,CAAC+F,KAAV;AACE;AACA,cAAIE,SAAS,GAAG,EAAhB,EAAoB;AAClB;AACA;AACAC,cAAE;AAAG;AAA6BC,kBAAM,CAACC,YAAP,CAAoB,KAAKH,SAAzB,CAAlC;AACD,WAJD,MAIO;AACL,oBAAQA,SAAR;AACE,mBAAK,EAAL;AACEC,kBAAE,GAAG,GAAL;AACA;;AACF,mBAAKtF,sBAAsB,CAACyF,EAA5B;AACEP,uBAAO,GAAG9F,IAAI,CAACsG,KAAf;AACA;;AACF,mBAAK1F,sBAAsB,CAAC2F,EAA5B;AACET,uBAAO,GAAG9F,IAAI,CAACwG,KAAf;AACA;;AACF,mBAAK5F,sBAAsB,CAAC6F,EAA5B;AACE;AACAT,gCAAgB,GAAGF,OAAnB;AACAA,uBAAO,GAAG9F,IAAI,CAAC0G,WAAf;AACA;;AACF,mBAAK9F,sBAAsB,CAACkB,kCAA5B;AACEf,sBAAM,CAACgB,MAAP;AAAc;AAAW2D,kCAAkB,CAAC/E,CAAD,CAA3C;AACA;;AACF,mBAAKC,sBAAsB,CAACa,0BAA5B;AACEqE,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;AApBJ;AAsBD;;AACD;;AAEF,aAAK/F,IAAI,CAACsG,KAAV;AACE;AACA,cAAIL,SAAS,GAAG,EAAhB,EAAoB;AAClBC,cAAE;AAAG;AAA2BC,kBAAM,CAACC,YAAP,CAAoB,KAAKH,SAAzB,CAAhC;AACD,WAFD,MAEO;AACL,oBAAQA,SAAR;AACE,mBAAK,EAAL;AACEC,kBAAE,GAAG,GAAL;AACA;;AACF,mBAAKtF,sBAAsB,CAAC+F,EAA5B;AACE;AACAX,gCAAgB,GAAGF,OAAnB;AACAA,uBAAO,GAAG9F,IAAI,CAAC4G,WAAf;AACA;;AACF,mBAAKhG,sBAAsB,CAAC2F,EAA5B;AACET,uBAAO,GAAG9F,IAAI,CAACwG,KAAf;AACA;;AACF,mBAAK5F,sBAAsB,CAAC6F,EAA5B;AACE;AACAT,gCAAgB,GAAGF,OAAnB;AACAA,uBAAO,GAAG9F,IAAI,CAAC0G,WAAf;AACA;;AACF,mBAAK9F,sBAAsB,CAACkB,kCAA5B;AACE;AACAf,sBAAM,CAACgB,MAAP;AAAc;AAAW2D,kCAAkB,CAAC/E,CAAD,CAA3C;AACA;;AACF,mBAAKC,sBAAsB,CAACa,0BAA5B;AACEqE,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;AAvBJ;AAyBD;;AACD;;AAEF,aAAK/F,IAAI,CAACwG,KAAV;AACE;AACA,cAAIP,SAAS,GAAGrF,sBAAsB,CAACiG,EAAvC,EAA2C;AACzCX,cAAE,GAAGtF,sBAAsB,CAACkG,WAAvB,CAAmCb,SAAnC,CAAL;AACD,WAFD,MAEO;AACL,oBAAQA,SAAR;AACE,mBAAKrF,sBAAsB,CAACiG,EAA5B;AACEf,uBAAO,GAAG9F,IAAI,CAAC+G,KAAf;AACA;;AACF,mBAAK,EAAL;AACEb,kBAAE,GAAG,GAAL;AACA;;AACF,mBAAKtF,sBAAsB,CAACyF,EAA5B;AACEP,uBAAO,GAAG9F,IAAI,CAACsG,KAAf;AACA;;AACF,mBAAK1F,sBAAsB,CAACoG,EAA5B;AACElB,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;;AACF,mBAAKnF,sBAAsB,CAAC6F,EAA5B;AACE;AACAT,gCAAgB,GAAGF,OAAnB;AACAA,uBAAO,GAAG9F,IAAI,CAAC0G,WAAf;AACA;;AACF,mBAAK9F,sBAAsB,CAACkB,kCAA5B;AACEf,sBAAM,CAACgB,MAAP;AAAc;AAAW2D,kCAAkB,CAAC/E,CAAD,CAA3C;AACA;;AACF,mBAAKC,sBAAsB,CAACa,0BAA5B;AACEqE,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;AAvBJ;AAyBD;;AACD;;AAEF,aAAK/F,IAAI,CAAC+G,KAAV;AACE;AACA,cAAId,SAAS,GAAGrF,sBAAsB,CAACqG,GAAvC,EAA4C;AAC1Cf,cAAE,GAAGtF,sBAAsB,CAACsG,WAAvB,CAAmCjB,SAAnC,CAAL;AACD,WAFD,MAEO;AACL,oBAAQA,SAAR;AACE,mBAAKrF,sBAAsB,CAACqG,GAA5B;AACEnB,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;;AACF,mBAAKnF,sBAAsB,CAACkB,kCAA5B;AACEf,sBAAM,CAACgB,MAAP;AAAc;AAAW2D,kCAAkB,CAAC/E,CAAD,CAA3C;AACA;;AACF,mBAAKC,sBAAsB,CAACa,0BAA5B;AACEqE,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;AATJ;AAWD;;AACD;;AAEF,aAAK/F,IAAI,CAAC4G,WAAV;AACE;AACAd,iBAAO,GAAGE,gBAAV;;AACA,cAAIC,SAAS,GAAG,EAAhB,EAAoB;AAClBC,cAAE;AAAG;AAA4BC,kBAAM,CAACC,YAAP,CAAoB,KAAKH,SAAzB,CAAjC;AACD,WAFD,MAEO;AACL,oBAAQA,SAAR;AACE,mBAAK,EAAL;AACEC,kBAAE,GAAG,GAAL;AACA;;AACF,mBAAKtF,sBAAsB,CAACa,0BAA5B;AACEqE,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;AANJ;AAQD;;AACD;;AAEF,aAAK/F,IAAI,CAAC0G,WAAV;AACE;AACAZ,iBAAO,GAAGE,gBAAV;;AACA,cAAIC,SAAS,GAAGrF,sBAAsB,CAACqG,GAAvC,EAA4C;AAC1Cf,cAAE,GAAGtF,sBAAsB,CAACsG,WAAvB,CAAmCjB,SAAnC,CAAL;AACD,WAFD,MAEO;AACL,oBAAQA,SAAR;AACE,mBAAKrF,sBAAsB,CAACqG,GAA5B;AACEnB,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;;AACF,mBAAKnF,sBAAsB,CAACkB,kCAA5B;AACE;AACA;AACAf,sBAAM,CAACgB,MAAP;AAAc;AAAW2D,kCAAkB,CAAC/E,CAAD,CAA3C;AACA;;AACF,mBAAKC,sBAAsB,CAACa,0BAA5B;AACEqE,uBAAO,GAAG9F,IAAI,CAAC+F,KAAf;AACA;AAXJ;AAaD;;AACD;AA3JJ,OAHiB,CAgKjB;;;AACA,UAAIG,EAAE,KAAK,EAAX,EAAe;AACb;AACAnF,cAAM,CAACgB,MAAP,CAAcmE,EAAd;AACD;;AACDvF,OAAC;AACF;AACF,GAlLc;AAoLf;;;;;;;;;;;;;;AAYuBC,0CAAvB,UAAsCuG,IAAtC,EACEtG,SADF,EAEEI,QAFF,EAGEI,SAHF,EAIEN,MAJF,EAIuB;AACrB,QAAIqG,YAAY,GAA0B,IAAIC,+BAAJ,EAA1C;AACA,QAAIC,KAAK,GAAQ,CAAjB;AACA,QAAIC,KAAK;AAAE;AAAkB,KAA7B;AACA,QAAI3B,GAAG,GAAY,KAAnB;;AAEA,YAAQuB,IAAR;AACE,WAAKvG,sBAAsB,CAACe,0BAA5B;AACE;AACA;AAEA,YAAI6F,sBAAsB,GAAe,IAAIpE,UAAJ,CAAe,CAAf,CAAzC;AACA,YAAIqE,QAAQ,GAAQ5G,SAAS,CAACQ,SAAS,EAAV,CAA7B;;AACA,eAAQA,SAAS,GAAGR,SAAS,CAAC,CAAD,CAAtB,IAA8B,CAAC+E,GAAtC,EAA2C;AACzC4B,gCAAsB,CAACF,KAAK,EAAN,CAAtB,GAAkCG,QAAlC,CADyC,CAEzC;;AACAF,eAAK,GAAG,MAAMA,KAAN,GAAcE,QAAtB;AACAA,kBAAQ,GAAG5G,SAAS,CAACQ,SAAS,EAAV,CAApB,CAJyC,CAKzC;;AACA,kBAAQoG,QAAR;AACE,iBAAK7G,sBAAsB,CAACa,0BAA5B;AACA,iBAAKb,sBAAsB,CAACe,0BAA5B;AACA,iBAAKf,sBAAsB,CAACoB,6BAA5B;AACA,iBAAKpB,sBAAsB,CAACgB,4BAA5B;AACA,iBAAKhB,sBAAsB,CAAC2B,gCAA5B;AACA,iBAAK3B,sBAAsB,CAAC6B,iCAA5B;AACA,iBAAK7B,sBAAsB,CAAC8B,uBAA5B;AACErB,uBAAS;AACTuE,iBAAG,GAAG,IAAN;AACA;;AACF;AACE,kBAAK0B,KAAK,GAAG,CAAR,KAAc,CAAf,IAAsBA,KAAK,GAAG,CAAlC,EAAsC;AACpC;AACA;AACA,qBAAK,IAAII;AAAE;AAAD,kBAAW,CAArB,EAAwBA,CAAC,GAAG,CAA5B,EAA+B,EAAEA,CAAjC,EAAoC;AAClC;;;;AAIAN,8BAAY,CAACO,KAAb;AAAmB;AAAUC,wBAAM,CAACtH,YAAY,CAACiH,KAAD,CAAZ,IAAuBjH,YAAY,CAAC,KAAK,IAAIoH,CAAT,CAAD,CAApC,CAAnC;AACD;;AACDH,qBAAK,GAAG,CAAR;AACAD,qBAAK,GAAG,CAAR;AACD;;AACD;AAzBJ;AA2BD,SAvCH,CAyCE;;;AACA,YAAIjG,SAAS,KAAKR,SAAS,CAAC,CAAD,CAAvB,IAA8B4G,QAAQ,GAAG7G,sBAAsB,CAACa,0BAApE,EAAgG;AAC9F+F,gCAAsB,CAACF,KAAK,EAAN,CAAtB,GAAkCG,QAAlC;AACD,SA5CH,CA8CE;AACA;AACA;;;AACA,aAAK,IAAI9G;AAAE;AAAD,UAAW,CAArB,EAAwBA,CAAC,GAAG2G,KAA5B,EAAmC3G,CAAC,EAApC,EAAwC;AACtCyG,sBAAY,CAACO,KAAb;AAAmB;AAAWH,gCAAsB,CAAC7G,CAAD,CAApD;AACD;;AAED;;AAEF,WAAKC,sBAAsB,CAACgB,4BAA5B;AACE;AACA;AACA,eAAOP,SAAS,GAAGR,SAAS,CAAC,CAAD,CAArB,IAA4B,CAAC+E,GAApC,EAAyC;AACvC,cAAItE,IAAI,GAAQT,SAAS,CAACQ,SAAS,EAAV,CAAzB;;AACA,cAAIC,IAAI,GAAGV,sBAAsB,CAACa,0BAAlC,EAA8D;AAC5D6F,iBAAK,GADuD,CAE5D;;AACAC,iBAAK,GAAG,MAAMA,KAAN,GAAcjG,IAAtB;AACD,WAJD,MAIO;AACL,oBAAQA,IAAR;AACE,mBAAKV,sBAAsB,CAACa,0BAA5B;AACA,mBAAKb,sBAAsB,CAACe,0BAA5B;AACA,mBAAKf,sBAAsB,CAACoB,6BAA5B;AACA,mBAAKpB,sBAAsB,CAACgB,4BAA5B;AACA,mBAAKhB,sBAAsB,CAAC2B,gCAA5B;AACA,mBAAK3B,sBAAsB,CAAC6B,iCAA5B;AACA,mBAAK7B,sBAAsB,CAAC8B,uBAA5B;AACErB,yBAAS;AACTuE,mBAAG,GAAG,IAAN;AACA;AAVJ;AAYD;;AACD,cAAK0B,KAAK,GAAG,CAAR,KAAc,CAAf,IAAsBA,KAAK,GAAG,CAAlC,EAAsC;AACpC;AACA;;AACA;;;;AAIA,iBAAK,IAAII;AAAE;AAAD,cAAW,CAArB,EAAwBA,CAAC,GAAG,CAA5B,EAA+B,EAAEA,CAAjC,EAAoC;AAClCN,0BAAY,CAACO,KAAb;AAAmB;AAAUC,oBAAM,CAACtH,YAAY,CAACiH,KAAD,CAAZ,IAAuBjH,YAAY,CAAC,KAAK,IAAIoH,CAAT,CAAD,CAApC,CAAnC;AACD;;AACDH,iBAAK,GAAG,CAAR;AACAD,iBAAK,GAAG,CAAR;AACD;AACF;;AACD;AA7FJ;;AA+FAvG,UAAM,CAACgB,MAAP,CAAc8F,yBAAeC,MAAf,CAAsBV,YAAY,CAACW,WAAb,EAAtB,EAAkD9G,QAAlD,CAAd;AACA,WAAOI,SAAP;AACD,GA3GsB;AA6GvB;;;;;;;;;;;;AAUeT,6CAAf,UAAiCC,SAAjC,EAAwDQ;AAAkB;AAA1E,IAAmFN,MAAnF,EAAwG;AACtG,QAAIuG,KAAK,GAAQ,CAAjB;AACA,QAAI1B,GAAG,GAAY,KAAnB;AAEA,QAAIoC,gBAAgB,GAAe,IAAI5E,UAAJ,CAAexC,sBAAsB,CAACqH,qBAAtC,CAAnC;;AAEA,WAAO5G,SAAS,GAAGR,SAAS,CAAC,CAAD,CAArB,IAA4B,CAAC+E,GAApC,EAAyC;AACvC,UAAItE,IAAI,GAAQT,SAAS,CAACQ,SAAS,EAAV,CAAzB;;AACA,UAAIA,SAAS,KAAKR,SAAS,CAAC,CAAD,CAA3B,EAAgC;AAC9B+E,WAAG,GAAG,IAAN;AACD;;AACD,UAAItE,IAAI,GAAGV,sBAAsB,CAACa,0BAAlC,EAA8D;AAC5DuG,wBAAgB,CAACV,KAAD,CAAhB,GAA0BhG,IAA1B;AACAgG,aAAK;AACN,OAHD,MAGO;AACL,gBAAQhG,IAAR;AACE,eAAKV,sBAAsB,CAACa,0BAA5B;AACA,eAAKb,sBAAsB,CAACe,0BAA5B;AACA,eAAKf,sBAAsB,CAACgB,4BAA5B;AACA,eAAKhB,sBAAsB,CAAC2B,gCAA5B;AACA,eAAK3B,sBAAsB,CAAC6B,iCAA5B;AACA,eAAK7B,sBAAsB,CAAC8B,uBAA5B;AACErB,qBAAS;AACTuE,eAAG,GAAG,IAAN;AACA;AATJ;AAWD;;AACD,UAAI,CAAC0B,KAAK,GAAG1G,sBAAsB,CAACqH,qBAA/B,KAAyD,CAAzD,IAA8D3G,IAAI,KAAKV,sBAAsB,CAACoB,6BAA9F,IAA+H4D,GAAhI,KAAwI0B,KAAK,GAAG,CAApJ,EAAuJ;AACrJ;AACA;AACA;AACA;AACAvG,cAAM,CAACgB,MAAP,CAAcnB,sBAAsB,CAAC4C,qBAAvB,CAA6CwE,gBAA7C,EAA+DV,KAA/D,CAAd;AACAA,aAAK,GAAG,CAAR;AACD;AACF;;AACD,WAAOjG,SAAP;AACD,GArCc;AAuCf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CeT,iDAAf,UAAqCC,SAArC,EAA4DyG,KAA5D,EAAsE;AACpE,QAAIvG,MAAM,GAAGT,YAAY,CAAC,CAAD,CAAzB;;AACA,SAAK,IAAIK;AAAE;AAAD,MAAW,CAArB,EAAwBA,CAAC,GAAG2G,KAA5B,EAAmC3G,CAAC,EAApC,EAAwC;AACtCI,YAAM,IAAIH,sBAAsB,CAACH,MAAvB,CAA8B6G,KAAK,GAAG3G,CAAR,GAAY,CAA1C,IAA+CL,YAAY,CAACO,SAAS,CAACF,CAAD,CAAV,CAArE;AACD;;AACD,QAAIuH,YAAY,GAAWnH,MAAM,CAACiC,QAAP,EAA3B;;AACA,QAAIkF,YAAY,CAACC,MAAb,CAAoB,CAApB,MAA2B,GAA/B,EAAoC;AAClC,YAAM,IAAIxF,yBAAJ,EAAN;AACD;;AACD,WAAOuF,YAAY,CAACE,SAAb,CAAuB,CAAvB,CAAP;AACD,GAVc;;AAvrBUxH,sDAAkC,GAAlC;AACAA,sDAAkC,GAAlC;AACAA,yDAAqC,GAArC;AACAA,wDAAoC,GAApC;AACAA,4CAAwB,GAAxB;AACAA,+CAA2B,GAA3B;AACAA,uCAAmB,GAAnB;AACAA,4DAAwC,GAAxC;AACAA,6DAAyC,GAAzC;AACAA,mDAA+B,GAA/B;AACAA,8DAA0C,GAA1C;AACAA,iDAA6B,EAA7B;AAEAA,iEAA6C,CAA7C;AACAA,qEAAiD,CAAjD;AACAA,kEAA8C,CAA9C;AACAA,8DAA0C,CAA1C;AACAA,iEAA6C,CAA7C;AACAA,iEAA6C,CAA7C;AACAA,gEAA4C,CAA5C;AAEAA,8BAAU,EAAV;AACAA,8BAAU,EAAV;AACAA,8BAAU,EAAV;AACAA,8BAAU,EAAV;AACAA,8BAAU,EAAV;AACAA,8BAAU,EAAV;AACAA,+BAAW,EAAX;AAEAA,uCACvB,oCADuB;AAGAA,uCACvB,6BADuB;AAGzB;;;;;AAIyBA,kCAAmBX,oBAAoB,KAAKO,SAAS,EAAd,GAAmB,EAA1D;AAEAI,wDAAoC,CAApC;AA0pB3B;AArsBA;;kBAA+BA","names":["Mode","getBigIntConstructor","window","global","Error","BigInteger","createBigInt","num","getEXP900","EXP900","nineHundred","i","DecodedBitStreamParser","codewords","ecLevel","result","StringBuilder_1","encoding","CharacterSetECI_1","ISO8859_1","enableDecoding","codeIndex","code","resultMetadata","PDF417ResultMetadata_1","TEXT_COMPACTION_MODE_LATCH","textCompaction","BYTE_COMPACTION_MODE_LATCH","BYTE_COMPACTION_MODE_LATCH_6","byteCompaction","MODE_SHIFT_TO_BYTE_COMPACTION_MODE","append","NUMERIC_COMPACTION_MODE_LATCH","numericCompaction","ECI_CHARSET","charsetECI","getCharacterSetECIByValue","ECI_GENERAL_PURPOSE","ECI_USER_DEFINED","BEGIN_MACRO_PDF417_CONTROL_BLOCK","decodeMacroBlock","BEGIN_MACRO_PDF417_OPTIONAL_FIELD","MACRO_PDF417_TERMINATOR","FormatException_1","length","getFormatInstance","decoderResult","DecoderResult_1","toString","setOther","NUMBER_OF_SEQUENCE_CODEWORDS","segmentIndexArray","Int32Array","setSegmentIndex","Integer_1","parseInt","decodeBase900toBase10","fileId","setFileId","optionalFieldsStart","MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME","fileName","setFileName","MACRO_PDF417_OPTIONAL_FIELD_SENDER","sender","setSender","MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE","addressee","setAddressee","MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT","segmentCount","setSegmentCount","MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP","timestamp","setTimestamp","Long_1","parseLong","MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM","checksum","setChecksum","MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE","fileSize","setFileSize","setLastSegment","optionalFieldsLength","isLastSegment","setOptionalData","Arrays_1","copyOfRange","textCompactionData","byteCompactionData","index","end","decodeTextCompaction","subMode","ALPHA","priorToShiftMode","subModeCh","ch","String","fromCharCode","LL","LOWER","ML","MIXED","PS","PUNCT_SHIFT","AS","ALPHA_SHIFT","PL","MIXED_CHARS","PUNCT","AL","PAL","PUNCT_CHARS","mode","decodedBytes","ByteArrayOutputStream_1","count","value","byteCompactedCodewords","nextCode","j","write","Number","StringEncoding_1","decode","toByteArray","numericCodewords","MAX_NUMERIC_CODEWORDS","resultString","charAt","substring"],"sources":["../../../../src/core/pdf417/decoder/DecodedBitStreamParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}